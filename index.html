<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Teoría Neo-Riemanniana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Darker text */
        }
        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn {
            @apply px-4 py-2 rounded-lg font-semibold transition-all duration-200 cursor-pointer;
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 shadow-lg transform hover:scale-105;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 shadow-md transform hover:scale-105;
        }
        /* Style for active operation button */
        .btn-secondary.active-op-btn {
            @apply bg-yellow-400 text-gray-900 border-2 border-yellow-600 shadow-xl transform scale-105;
        }

        /* Style for the operations box */
        #operationsBox {
            transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
        }
        /* New style for the active operations box */
        #operationsBox.operations-box-active {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5), 0 10px 20px -5px rgba(59, 130, 246, 0.3); /* Blue glow/shadow */
            border-color: #3b82f6; /* Brighter border */
        }

        .chord-display {
            @apply bg-blue-100 p-4 rounded-lg text-center my-4 border border-blue-200;
        }
        .history-item {
            @apply bg-gray-50 p-2 rounded-md mb-2 text-sm border border-gray-100;
        }
        .explanation-box {
            @apply bg-green-50 p-4 rounded-lg my-4 border border-green-100;
            min-height: 120px; /* Damos un alto mínimo para que no salte tanto la UI */
        }
        /* Custom styles for the circular visualization */
        .circle-container {
            position: relative;
            margin: 0 auto;
            border: 2px solid #cbd5e1;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8fafc; /* Lighter background for the circle */
            width: 100%; /* Fill parent width */
            height: 100%; /* Fill parent height */
        }
        .chord-node {
            position: absolute;
            width: 60px;
            height: 30px;
            background-color: #e2e8f0;
            border: 1px solid #94a3b8;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s ease-in-out, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chord-node.active {
            background-color: #3b82f6;
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 6px 12px -2px rgba(59, 130, 246, 0.4), 0 3px 7px -3px rgba(59, 130, 246, 0.3);
            animation: pulse 1.5s infinite alternate; /* Subtle pulse effect */
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.03); }
        }

        .arrow {
            position: absolute;
            stroke: #94a3b8; /* Lighter grey for default arrows */
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .arrow-active {
            stroke: #3b82f6;
            stroke-width: 3;
        }
        #arrowhead {
            fill: #94a3b8;
        }
        .arrow-active #arrowhead {
            fill: #3b82f6;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .container {
                margin: 1rem;
                padding: 1rem;
            }
            .chord-node {
                width: 50px;
                height: 25px;
                font-size: 0.65rem;
            }
            .circle-container {
                /* width: 250px; */ /* Removed fixed width */
                /* height: 250px; */ /* Removed fixed height */
            }
            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.875rem;
            }
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.2), 0 8px 15px -5px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        /* Collapsible section styles */
        .collapsible-header {
            @apply bg-blue-500 text-white p-3 rounded-lg cursor-pointer flex justify-between items-center mt-6 shadow-md;
        }
        .collapsible-header span {
            transition: transform 0.3s ease-in-out;
        }
        .collapsible-header.expanded span {
            transform: rotate(180deg);
        }
        .collapsible-content {
            @apply p-4 bg-white rounded-lg border border-gray-200 mt-2;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }
        .collapsible-content.show {
            max-height: 2000px; /* Increased for more content */
            transition: max-height 0.5s ease-in;
        }

        /* Tonnetz visualization specific styles */
        .tonnetz-node-circle { /* Renamed from .tonnetz-node to avoid conflict */
            transition: fill 0.2s ease-in-out, stroke 0.2s ease-in-out;
        }
        .tonnetz-node-circle.active {
            fill: #3b82f6;
            stroke: #1d4ed8;
        }
        .tonnetz-node-text {
            transition: fill 0.2s ease-in-out;
        }
        
        /* Toggle Switch Styles */
        .toggle-switch {
            @apply relative inline-flex items-center cursor-pointer;
        }
        .toggle-switch-input {
            @apply sr-only;
        }
        .toggle-switch-label {
            @apply relative inline-block w-14 h-8 bg-gray-300 rounded-full transition-colors duration-200 ease-in-out;
        }
        .toggle-switch-label:after {
            @apply content-[''] absolute left-1 top-1 w-6 h-6 bg-white rounded-full shadow-md transition-transform duration-200 ease-in-out;
        }
        .toggle-switch-input:checked + .toggle-switch-label {
            @apply bg-blue-600;
        }
        .toggle-switch-input:checked + .toggle-switch-label:after {
            @apply transform translate-x-6;
        }
    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-blue-700">Explorador de Teoría Neo-Riemanniana</h1>
        <p class="text-gray-700 mb-6 text-center">
            Bienvenido a este entorno interactivo para explorar las operaciones de la Teoría Neo-Riemanniana.
            Selecciona un acorde inicial y aplica las operaciones para ver cómo transforman las tríadas y cómo se relacionan en el espacio tonal cromático.
        </p>

        <div class="flex flex-col md:flex-row gap-6">
            <div class="md:w-1/2">
                <div class="mb-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <label for="startChord" class="block text-gray-700 text-sm font-bold mb-2">Selecciona un acorde inicial:</label>
                    <select id="startChord" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                        <!-- Options will be populated by JS -->
                    </select>
                    <div class="flex gap-3">
                        <button id="resetButton" class="btn btn-primary w-1/2 mt-3">Reiniciar</button>
                        <button id="glossaryButton" class="btn btn-secondary w-1/2 mt-3">Glosario</button>
                    </div>
                </div>

                <div class="chord-display">
                    <div class="flex justify-center items-center gap-4">
                        <div class="text-center"> <!-- Mantenemos el texto centrado -->
                            <h2 class="text-xl font-bold mb-2 text-blue-800">Acorde Actual: <span id="currentChordName">C Mayor</span></h2>
                            <p class="text-lg text-gray-700">Notas: <span id="currentChordNotes">C, E, G</span></p>
                        </div>
                        <button id="playChordButton" class="btn btn-secondary p-3 rounded-full shadow-lg transform hover:scale-110 active:scale-100">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                            </svg>
                        </button>
                    </div>
                </div>

                <div id="operationsBox" class="mb-4 p-4 bg-blue-50 rounded-lg shadow-inner border border-blue-100"> <!-- Colored box for operations -->
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Operaciones:</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                        <button id="opL" class="btn btn-secondary" data-op="L">L (Leittonechel)</button>
                        <button id="opP" class="btn btn-secondary" data-op="P">P (Parallel)</button>
                        <button id="opR" class="btn btn-secondary" data-op="R">R (Relative)</button>
                        <button id="opN" class="btn btn-secondary" data-op="N">N (Next Related)</button>
                        <button id="opH" class="btn btn-secondary" data-op="H">H (Hexatonic Pole)</button>
                        <button id="opS" class="btn btn-secondary" data-op="S">S (Slide)</button>
                    </div>
                </div>

                <div class="explanation-box">
                    <h3 class="text-lg font-semibold mb-2 text-green-800">Explicación de la Operación:</h3>
                    <p id="operationExplanation" class="text-gray-800 text-sm">Selecciona una operación para ver su descripción.</p>
                </div>

                <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Historial de Transformaciones:</h3>
                    <div id="historyLog" class="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2 bg-white">
                        <!-- History items will be added here -->
                    </div>
                </div>

                <!-- New UI Section for Set Relationships -->
                <div class="p-4 bg-gray-50 rounded-lg shadow-inner mt-6">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Relación entre Conjuntos:</h3>
                    <div id="setRelationships" class="bg-white p-3 rounded-lg border border-gray-200">
                        <p class="mb-2"><strong class="text-blue-700">Ciclo Hexatónico Actual:</strong> <span id="currentHexatonicCycle"></span></p>
                        <div id="hexatonicCycleMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-green-700">Región de Weitzmann Actual:</strong> <span id="currentWeitzmannRegion"></span></p>
                        <div id="weitzmannRegionMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-purple-700">Acordes Compartidos:</strong></p>
                        <div id="sharedChords" class="flex flex-wrap gap-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Container for both visualizations -->
            <div class="md:w-1/2 flex flex-col md:flex-row gap-6"> 
                <!-- Hexatonic Cycle Visualization -->
                <div class="flex-1 p-4 flex flex-col items-center justify-center bg-white rounded-lg shadow-inner border border-blue-100 h-[400px]">
                    
                    <!-- Título y Toggle Switch -->
                    <div class="flex items-center justify-between w-full mb-3">
                        <h3 id="circleTitle" class="text-lg font-semibold text-gray-800">Visualización (Ciclo L/P)</h3>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm font-medium text-gray-700">L/P</span>
                            <label for="vizToggle" class="toggle-switch">
                                <input type="checkbox" id="vizToggle" class="toggle-switch-input">
                                <span class="toggle-switch-label"></span>
                            </label>
                            <span class="text-sm font-medium text-gray-700">R/N</span>
                        </div>
                    </div>

                    <div id="hexatonicCircle" class="circle-container w-full h-full">
                        <svg width="100%" height="100%" viewBox="0 0 300 300">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" />
                                </marker>
                            </defs>
                            <!-- Nodes will be added dynamically -->
                        </svg>
                    </div>
                    <p id="circleDescription" class="text-sm text-gray-600 mt-2 text-center">
                        Esta visualización muestra un ciclo hexatónico (L/P).
                        Las operaciones R, N y S pueden llevarte a un ciclo diferente.
                    </p>
                </div>

                <!-- Dynamic Tonnetz Visualization Section -->
                <div class="flex-1 p-4 bg-white rounded-lg shadow-inner border border-blue-100 flex flex-col items-center justify-center h-[400px]">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800 text-center">Visualización Dinámica del Tonnetz</h3>
                    <div id="tonnetzVisualization" class="w-full h-full border border-gray-200 rounded-lg bg-white flex justify-center items-center">
                        <!-- SVG Tonnetz will be drawn here dynamically -->
                    </div>
                    <p class="text-sm text-gray-600 mt-2 text-center">
                        Esta es una representación dinámica de un segmento del Tonnetz.
                        Las notas del acorde actual se resaltarán en azul (mayor) o rojo (menor).
                    </p>
                </div>
            </div>
        </div>


        <!-- Tonnetz Explanation Section -->
        <!-- Removed collapsible-header and collapsible-content for Tonnetz Explanation -->

        <p class="text-center text-gray-700 text-sm font-semibold mt-8">
            Herramienta realizada por Juan Miguel Ríos Redondo
        </p>
    </div>

    <!-- Modal for author information -->
    <div id="authorModal" class="modal-overlay">
        <div class="modal-content">
            <p class="text-gray-800 text-lg">Esta herramienta fue realizada por:</p>
            <p class="text-blue-600 text-2xl font-bold mt-2">Juan Miguel Ríos Redondo</p>
        </div>
    </div>

    <!-- Modal para Glosario -->
    <div id="glossaryModal" class="modal-overlay">
        <div class="modal-content text-left w-full max-w-lg">
            <h2 class="text-2xl font-bold text-center mb-6 text-blue-700">Glosario de Términos</h2>
            <div class="space-y-4">
                <div>
                    <h3 class="font-semibold text-lg text-gray-800">Involución</h3>
                    <p class="text-gray-700">Una operación que es su propio inverso. Al aplicarla dos veces consecutivas, se vuelve al punto de partida.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-gray-800">Conducción Idealizada</h3>
                    <p class="text-gray-700">Aquella conducción en la que los acordes se disponen de manera tal que cada voz se desplace la menor distancia posible, manteniendo fijas las notas en común.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-gray-800">Operación Compuesta</h3>
                    <p class="text-gray-700">Dos o tres operaciones simples condensadas en una sola (ej. H es PLP, S es RNR).</p>
                </div>
            </div>
            <button id="closeGlossaryButton" class="btn btn-primary mt-8 w-full">Cerrar</button>
        </div>
    </div>

    <script>
        // Flag to ensure the modal only shows once per page load
        let hasModalBeenShown = false;

        // --- Audio Context ---
        let isToneStarted = false;
        const synth = new Tone.PolySynth(Tone.Synth).toDestination();
        let lastPlayedVoicing = []; // NUEVO: Guarda el último voicing reproducido (como array de notas, ej: ["C4", "E4", "G4"])

        async function startAudioContext() {
            if (isToneStarted) return;
            try {
                await Tone.start();
                isToneStarted = true;
                console.log("Audio context started.");
            } catch (e) {
                console.error("Could not start audio context", e);
            }
        }

        // --- Funciones de Audio y Voice Leading ---

        /**
         * Reproduce un array de notas MIDI y lo guarda como el último voicing.
         */
        function playVoicing(midiNotes) {
            startAudioContext();
            // Convierte MIDI a nombres de nota para Tone.js (ej: 60 -> "C4")
            const toneNotes = midiNotes.map(midi => Tone.Frequency(midi, "midi").toNote());
            
            lastPlayedVoicing = toneNotes; // Guarda el nuevo voicing
            synth.triggerAttackRelease(toneNotes, "1s");
        }

        /**
         * Calcula el voicing más cercano para 'toTriad' partiendo de 'fromMidiNotes'.
         * Mantiene las notas comunes y mueve las restantes la distancia mínima.
         */
        function getClosestVoicing(fromMidiNotes, toTriad) {
            const fromPcs = fromMidiNotes.map(m => m % 12);
            const toPcs = toTriad.pitchClasses;
            
            const newVoicingMidi = [];
            const remainingToPcs = [...toPcs]; // PCs de destino que aún no han sido asignados
            const unmovedMidiNotes = []; // Notas MIDI de 'from' que se quedan
            const movedFromMidiNotes = []; // Notas MIDI de 'from' que deben moverse

            // 1. Encontrar y mantener notas comunes
            fromMidiNotes.forEach(midi => {
                const pc = midi % 12;
                const indexInTo = remainingToPcs.indexOf(pc);
                if (indexInTo !== -1) {
                    newVoicingMidi.push(midi); // Mantener la nota MIDI exacta
                    unmovedMidiNotes.push(midi);
                    remainingToPcs.splice(indexInTo, 1); // Este PC ya está asignado
                } else {
                    movedFromMidiNotes.push(midi); // Esta nota deberá moverse
                }
            });

            // 2. Asignar las notas que se mueven ('movedFromMidiNotes') a los PCs restantes ('remainingToPcs')
            movedFromMidiNotes.forEach(fromMidi => {
                let closestDist = Infinity;
                let bestNewMidi = 0;
                let bestPcIndex = -1;

                // Encontrar el PC de destino más cercano para esta nota
                remainingToPcs.forEach((toPc, index) => {
                    const baseOctave = Math.floor(fromMidi / 12);
                    const midiOpt1 = baseOctave * 12 + toPc; // Misma octava
                    const midiOpt2 = (baseOctave - 1) * 12 + toPc; // Octava abajo
                    const midiOpt3 = (baseOctave + 1) * 12 + toPc; // Octava arriba

                    const dist1 = Math.abs(midiOpt1 - fromMidi);
                    const dist2 = Math.abs(midiOpt2 - fromMidi);
                    const dist3 = Math.abs(midiOpt3 - fromMidi);

                    let currentClosestMidi;
                    let currentMinDist;

                    if (dist1 <= dist2 && dist1 <= dist3) {
                        currentMinDist = dist1; currentClosestMidi = midiOpt1;
                    } else if (dist2 < dist1 && dist2 < dist3) {
                        currentMinDist = dist2; currentClosestMidi = midiOpt2;
                    } else {
                        currentMinDist = dist3; currentClosestMidi = midiOpt3;
                    }

                    // Si esta es la mejor coincidencia encontrada HASTA AHORA para esta nota 'fromMidi'
                    if (currentMinDist < closestDist) {
                        closestDist = currentMinDist;
                        bestNewMidi = currentClosestMidi;
                        bestPcIndex = index;
                    }
                });

                // Asignar la mejor nota MIDI encontrada y eliminar el PC de la lista de destinos
                if (bestPcIndex !== -1) {
                    newVoicingMidi.push(bestNewMidi);
                    remainingToPcs.splice(bestPcIndex, 1);
                }
            });

            return newVoicingMidi;
        }


        // Mapping from pitch class number to note name (using sharps as primary)
        const pitchClasses = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"]; // Using Unicode sharps
        
        // Mapping from note name to pitch class number (handles both sharps and flats)
        const noteToPitchClass = {
            "C": 0, "C♯": 1, "D♭": 1, "D": 2, "D♯": 3, "E♭": 3, "E": 4, "F": 5, "F♯": 6, "G♭": 6, "G": 7, "G♯": 8, "A♭": 8, "A": 9, "A♯": 10, "B♭": 10, "B": 11
        };

        // Define a canonical spelling for each pitch class (prefer sharps by default)
        const canonicalSpelling = {
            0: "C", 1: "C♯", 2: "D", 3: "D♯", 4: "E", 5: "F",
            6: "F♯", 7: "G", 8: "G♯", 9: "A", 10: "A♯", 11: "B"
        };

        // Specific pitch class mapping for Tonnetz display notes (including enharmonic spellings as they appear in the image)
        const tonnetzNoteToPc = {
            "C": 0, "C♯": 1, "D♭": 1, "D": 2, "D♯": 3, "E♭": 3, "E": 4, "E♯": 5, "F": 5, "F♯": 6, "G♭": 6, "G": 7, "G♯": 8, "A♭": 8, "A": 9, "A♯": 10, "B♭": 10, "B": 11, "B♯": 0, "C♭": 11, "F♭": 4, "Gx": 9, "Ax": 11
        };

        // Function to normalize a pitch class (keep it within 0-11)
        function normalizePitch(pc) {
            return (pc % 12 + 12) % 12;
        }

        // Triad class
        class Triad {
            constructor(root, type) {
                this.root = root; // Note name (e.g., "C", "C#", "Db")
                this.type = type; // "major" or "minor"
                this.pitchClasses = this.calculatePitchClasses();
                this.name = `${root} ${type === 'major' ? 'Mayor' : 'menor'}`;
            }

            calculatePitchClasses() {
                const rootPc = noteToPitchClass[this.root];
                let thirdPc, fifthPc;

                if (this.type === "major") {
                    thirdPc = normalizePitch(rootPc + 4); // Major third
                    fifthPc = normalizePitch(rootPc + 7); // Perfect fifth
                } else { // minor
                    thirdPc = normalizePitch(rootPc + 3); // Minor third
                    fifthPc = normalizePitch(rootPc + 7); // Perfect fifth
                }
                return [rootPc, thirdPc, fifthPc];
            }

            getNotes() {
                const notes = [];
                
                // Root note (always use the triad's root name as is)
                notes.push(this.root);

                const thirdPc = this.pitchClasses[1];
                const fifthPc = this.pitchClasses[2];

                // Helper to get the correct enharmonic spelling based on the root of the triad
                const getNoteSpelling = (pc) => {
                    // Special cases for C# Major (E#) and F# Major (B#)
                    if (this.root === "C♯" && this.type === "major" && pc === 5) return "E♯"; // F -> E#
                    if (this.root === "F♯" && this.type === "major" && pc === 0) return "B♯"; // C -> B#

                    // Determine if we should generally prefer flat spellings for the internal notes
                    // This is a heuristic based on the root of the chord and common musical practice
                    const preferFlats = ["D♭", "E♭", "G♭", "A♭", "B♭"].includes(this.root) || // If root is explicitly flat
                                        (this.root === "F") || // F major/minor often use Bb
                                        (this.root === "C" && this.type === "minor") || // Cm uses Eb
                                        (this.root === "G" && this.type === "minor"); // Gm uses Bb

                    // Specific checks for common flat notes based on pitch class and context
                    if (pc === 11 && preferFlats) return "C♭"; // B -> Cb (e.g., in Ab minor)
                    if (pc === 4 && preferFlats) return "F♭";  // E -> Fb (e.g., in Db major)
                    if (pc === 1 && preferFlats) return "D♭";
                    if (pc === 3 && preferFlats) return "E♭";
                    if (pc === 6 && preferFlats) return "G♭";
                    if (pc === 8 && preferFlats) return "A♭";
                    if (pc === 10 && preferFlats) return "B♭";

                    // Otherwise, use canonical (sharp/natural) spelling
                    return canonicalSpelling[pc];
                };

                notes.push(getNoteSpelling(thirdPc)); // Third
                notes.push(getNoteSpelling(fifthPc)); // Fifth

                return notes;
            }

            // Checks if two triads are the same (same root and type)
            isEqual(otherTriad) {
                return this.root === otherTriad.root && this.type === otherTriad.type;
            }

            // Checks if two triads have the same pitch classes (enharmonic equivalence)
            hasSamePitchClasses(otherTriad) {
                const sortedThis = [...this.pitchClasses].sort();
                const sortedOther = [...otherTriad.pitchClasses].sort();
                return sortedThis.every((pc, i) => pc === sortedOther[i]);
            }
        }

        // Define all 12 unique root names to create all 24 triads
        const allPossibleRootNames = ["C", "C♯", "D♭", "D", "D♯", "E♭", "E", "F", "F♯", "G♭", "G", "G♯", "A♭", "A", "A♯", "B♭", "B"];

        // All possible major and minor triads (24 total) generated from allPossibleRootNames
        const allTriads = [];
        allPossibleRootNames.forEach(root => {
            if (noteToPitchClass[root] !== undefined) {
                allTriads.push(new Triad(root, "major"));
                allTriads.push(new Triad(root, "minor")); 
            }
        });

        // Helper to get a Triad object by name
        function getTriadByName(name) {
            return allTriads.find(t => t.name === name);
        }

        // --- Neo-Riemannian Operations ---
        function opL(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                // Example: C Major (0, 4, 7) -> E minor (4, 7, 11)
                // C (0) -> B (11)
                newPcs = [t, f, normalizePitch(r - 1)]; 
                newType = "minor";
            } else {
                // Example: E minor (4, 7, 11) -> C Major (0, 4, 7)
                // B (11) -> C (0)
                newPcs = [normalizePitch(f + 1), r, t];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opP(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                newPcs = [r, normalizePitch(t - 1), f];
                newType = "minor";
            } else {
                newPcs = [r, normalizePitch(t + 1), f];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opR(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                // C Major (0, 4, 7) -> A minor (9, 0, 4)
                // Common notes C (0) [r] and E (4) [t].
                // G (7) [f] moves to A (9) [f+2].
                // New triad root is A (9) [f+2], third is C (0) [r], fifth is E (4) [t]
                 newPcs = [normalizePitch(f + 2), r, t];
                 newType = "minor";
            } else { // minor
                // A minor (9, 0, 4) -> C Major (0, 4, 7)
                // Common notes are C (0) [t] and E (4) [f].
                // A (9) [r] moves to G (7) [r-2].
                // New triad root is C (0) [t], third is E (4) [f], fifth is G (7) [r-2]
                newPcs = [t, f, normalizePitch(r - 2)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }
        
        // Re-implementing opN based on PDF logic
        function opN(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                // C Major (0, 4, 7) -> F minor (5, 8, 0)
                // C (0) is common (becomes new 5th)
                // E (4) -> F (5) [t+1]
                // G (7) -> Ab (8) [f+1]
                // New triad: F (5) [t+1], Ab (8) [f+1], C (0) [r]
                newPcs = [normalizePitch(t + 1), normalizePitch(f + 1), r];
                newType = "minor";
            } else {
                // F minor (5, 8, 0) -> C Major (0, 4, 7)
                // C (0) is common (becomes new root)
                // F (5) -> E (4) [r-1]
                // Ab (8) -> G (7) [t-1]
                // New triad: C (0) [f], E (4) [r-1], G (7) [t-1]
                newPcs = [f, normalizePitch(r - 1), normalizePitch(t - 1)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }


        function opH(triad) {
            let result = opP(triad);
            result = opL(result);
            result = opP(result);
            return result;
        }

        // Re-implementing opS based on PDF logic
        function opS(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                // C Major (0, 4, 7) -> C# minor (1, 4, 8)
                // E (4) is common (new third)
                // C (0) -> C# (1) [r+1]
                // G (7) -> G# (8) [f+1]
                // New triad: C# (1) [r+1], E (4) [t], G# (8) [f+1]
                newPcs = [normalizePitch(r + 1), t, normalizePitch(f + 1)];
                newType = "minor";
            } else {
                // C# minor (1, 4, 8) -> C Major (0, 4, 7)
                // E (4) is common (new third)
                // C# (1) -> C (0) [r-1]
                // G# (8) -> G (7) [f-1]
                // New triad: C (0) [r-1], E (4) [t], G (7) [f-1]
                newPcs = [normalizePitch(r - 1), t, normalizePitch(f - 1)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }


        // Corrected Pre-defined Hexatonic Cycles (dynamically generated for accuracy)
        const hexatonicCycles = [
            { name: "Ciclo I (C/E/G♯)", members: [] },
            { name: "Ciclo II (C♯/F/A)", members: [] },
            { name: "Ciclo III (D/F♯/B♭)", members: [] },
            { name: "Ciclo IV (D♯/G/B)", members: [] }
        ];
        
        // --- Pre-defined Weitzmann Cycles ---
        const weitzmannCycles = [
            { name: "Región I (C-E-G♯)", members: [] },
            { name: "Región II (C♯-F-A)", members: [] },
            { name: "Región III (D-F♯-B♭)", members: [] },
            { name: "Región IV (D♯-G-B)", members: [] }
        ];

        function generateAndPopulateHexatonicCycle(startMajorTriad, cycleIndex) {
            const cycle = [];
            let current = startMajorTriad;
            for (let i = 0; i < 6; i++) {
                cycle.push(current);
                if (i % 2 === 0) { // Apply L
                    current = opL(current);
                } else { // Apply P
                    current = opP(current);
                }
            }
            hexatonicCycles[cycleIndex].members = cycle.filter(Boolean);
        }
        
        function generateAndPopulateWeitzmannCycle(startMajorTriad, cycleIndex) {
            const cycle = [];
            let current = startMajorTriad;
            for (let i = 0; i < 6; i++) {
                cycle.push(current);
                if (i % 2 === 0) { // Apply R
                    current = opR(current);
                } else { // Apply N
                    current = opN(current);
                }
            }
            weitzmannCycles[cycleIndex].members = cycle.filter(Boolean);
        }

        // Populate hexatonic cycles after allTriads and operations are defined
        // Ensure these starting triads exist in allTriads.
        generateAndPopulateHexatonicCycle(getTriadByName("C Mayor"), 0);
        generateAndPopulateHexatonicCycle(getTriadByName("C♯ Mayor"), 1);
        generateAndPopulateHexatonicCycle(getTriadByName("D Mayor"), 2);
        generateAndPopulateHexatonicCycle(getTriadByName("D♯ Mayor"), 3);
        
        // Populate Weitzmann cycles
        generateAndPopulateWeitzmannCycle(getTriadByName("C Mayor"), 0);
        generateAndPopulateWeitzmannCycle(getTriadByName("C♯ Mayor"), 1);
        generateAndPopulateWeitzmannCycle(getTriadByName("D Mayor"), 2);
        generateAndPopulateWeitzmannCycle(getTriadByName("D♯ Mayor"), 3);


        // Pre-defined Weitzmann Regions
        const weitzmannRegions = [
            { name: "Región de C-E-G♯", members: [
                getTriadByName("C Mayor"), getTriadByName("C menor"),
                getTriadByName("E Mayor"), getTriadByName("E menor"),
                getTriadByName("G♯ Mayor"), getTriadByName("G♯ menor")
            ].filter(Boolean)},
            { name: "Región de C♯-F-A", members: [
                getTriadByName("C♯ Mayor"), getTriadByName("C♯ menor"),
                getTriadByName("F Mayor"), getTriadByName("F menor"),
                getTriadByName("A Mayor"), getTriadByName("A menor")
            ].filter(Boolean)},
            { name: "Región de D-F♯-B♭", members: [
                getTriadByName("D Mayor"), getTriadByName("D menor"),
                getTriadByName("F♯ Mayor"), getTriadByName("F♯ menor"),
                getTriadByName("B♭ Mayor"), getTriadByName("B♭ menor") 
            ].filter(Boolean)},
            { name: "Región de D♯-G-B", members: [
                getTriadByName("D♯ Mayor"), getTriadByName("D♯ menor"),
                getTriadByName("G Mayor"), getTriadByName("G menor"),
                getTriadByName("B Mayor"), getTriadByName("B menor")
            ].filter(Boolean)}
        ];


        // Global state
        let currentTriad;
        let history = [];
        let currentCircleChords = []; // Chords for the current circle visualization
        let currentVisualizationMode = 'hexatonic'; // 'hexatonic' or 'weitzmann'

        // DOM Elements
        const startChordSelect = document.getElementById("startChord");
        const resetButton = document.getElementById("resetButton");
        const currentChordName = document.getElementById("currentChordName");
        const currentChordNotes = document.getElementById("currentChordNotes");
        const operationExplanation = document.getElementById("operationExplanation");
        const historyLog = document.getElementById("historyLog");
        const hexatonicCircleSvg = document.querySelector("#hexatonicCircle svg");
        const operationButtons = document.querySelectorAll('.grid button'); // All operation buttons
        const operationsBox = document.getElementById('operationsBox'); // The container for operation buttons
        const playChordButton = document.getElementById('playChordButton'); // Botón de reproducir
        const vizToggle = document.getElementById('vizToggle'); // El nuevo interruptor
        const circleTitle = document.getElementById('circleTitle'); // Título del círculo
        const circleDescription = document.getElementById('circleDescription'); // Descripción del círculo

        // DOM elements for new Set Relationships section
        const currentHexatonicCycleSpan = document.getElementById("currentHexatonicCycle");
        const hexatonicCycleMembersDiv = document.getElementById("hexatonicCycleMembers");
        const currentWeitzmannRegionSpan = document.getElementById("currentWeitzmannRegion");
        const weitzmannRegionMembersDiv = document.getElementById("weitzmannRegionMembers");
        const sharedChordsDiv = document.getElementById("sharedChords");
        const setRelationshipsDiv = document.getElementById('setRelationships'); // Contenedor para la delegación de eventos
        const authorModal = document.getElementById('authorModal'); // Modal element
        const glossaryButton = document.getElementById('glossaryButton');
        const glossaryModal = document.getElementById('glossaryModal');
        const closeGlossaryButton = document.getElementById('closeGlossaryButton');

        // Tonnetz explanation elements
        const tonnetzHeader = document.getElementById('tonnetzHeader');
        const tonnetzContent = document.getElementById('tonnetzContent');

        // New Tonnetz visualization elements
        const tonnetzVisualizerDiv = document.getElementById('tonnetzVisualization'); 
        const tonnetzSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        tonnetzSvg.setAttribute("width", "100%");
        tonnetzSvg.setAttribute("height", "100%"); // Make it fill parent
        tonnetzVisualizerDiv.appendChild(tonnetzSvg);

        // Global coordToNodeMap for quick lookup
        let coordToNodeMap = new Map();

        // Define spacing constants for the Tonnetz grid based on the image
        const P5_HORIZONTAL_SPACING = 80; // Horizontal distance for a perfect fifth
        const THIRD_VERTICAL_SPACING = 45; // Vertical distance for a major/minor third
        const THIRD_HORIZONTAL_OFFSET = P5_HORIZONTAL_SPACING / 2; // Horizontal offset for thirds

        // Define the Tonnetz nodes with their precise coordinates and note names as in the image
        // Using Unicode flat and sharp symbols for exact match with the image
        const tonnetzNodesData = [
            // Row 1: D# A# E# B# Gx
            { note: "D♯", pc: tonnetzNoteToPc["D♯"], x: 0, y: 0 },
            { note: "A♯", pc: tonnetzNoteToPc["A♯"], x: 80, y: 0 },
            { note: "E♯", pc: tonnetzNoteToPc["E♯"], x: 160, y: 0 },
            { note: "B♯", pc: tonnetzNoteToPc["B♯"], x: 240, y: 0 },
            { note: "Gx", pc: tonnetzNoteToPc["Gx"], x: 320, y: 0 },

            // Row 2: B F# C# G# D# A#
            { note: "B", pc: tonnetzNoteToPc["B"], x: -40, y: 45 },
            { note: "F♯", pc: tonnetzNoteToPc["F♯"], x: 40, y: 45 },
            { note: "C♯", pc: tonnetzNoteToPc["C♯"], x: 120, y: 45 },
            { note: "G♯", pc: tonnetzNoteToPc["G♯"], x: 200, y: 45 },
            { note: "D♯", pc: tonnetzNoteToPc["D♯"], x: 280, y: 45 },
            { note: "A♯", pc: tonnetzNoteToPc["A♯"], x: 360, y: 45 },

            // Row 3: D A E B F# C#
            { note: "D", pc: tonnetzNoteToPc["D"], x: 0, y: 90 },
            { note: "A", pc: tonnetzNoteToPc["A"], x: 80, y: 90 },
            { note: "E", pc: tonnetzNoteToPc["E"], x: 160, y: 90 },
            { note: "B", pc: tonnetzNoteToPc["B"], x: 240, y: 90 },
            { note: "F♯", pc: tonnetzNoteToPc["F♯"], x: 320, y: 90 },
            { note: "C♯", pc: tonnetzNoteToPc["C♯"], x: 400, y: 90 },

            // Row 4: Bb F C G D A
            { note: "B♭", pc: tonnetzNoteToPc["B♭"], x: -40, y: 135 },
            { note: "F", pc: tonnetzNoteToPc["F"], x: 40, y: 135 },
            { note: "C", pc: tonnetzNoteToPc["C"], x: 120, y: 135 },
            { note: "G", pc: tonnetzNoteToPc["G"], x: 200, y: 135 },
            { note: "D", pc: tonnetzNoteToPc["D"], x: 280, y: 135 },
            { note: "A", pc: tonnetzNoteToPc["A"], x: 360, y: 135 },

            // Row 5: Db Ab Eb Bb F C
            { note: "D♭", pc: tonnetzNoteToPc["D♭"], x: 0, y: 180 },
            { note: "A♭", pc: tonnetzNoteToPc["A♭"], x: 80, y: 180 },
            { note: "E♭", pc: tonnetzNoteToPc["E♭"], x: 160, y: 180 },
            { note: "B♭", pc: tonnetzNoteToPc["B♭"], x: 240, y: 180 },
            { note: "F", pc: tonnetzNoteToPc["F"], x: 320, y: 180 },
            { note: "C", pc: tonnetzNoteToPc["C"], x: 400, y: 180 },

            // Row 6: Ax Fb Cb Gb Db Ab
            { note: "Ax", pc: tonnetzNoteToPc["Ax"], x: -40, y: 225 },
            { note: "F♭", pc: tonnetzNoteToPc["F♭"], x: 40, y: 225 },
            { note: "C♭", pc: tonnetzNoteToPc["C♭"], x: 120, y: 225 },
            { note: "G♭", pc: tonnetzNoteToPc["G♭"], x: 200, y: 225 },
            { note: "D♭", pc: tonnetzNoteToPc["D♭"], x: 280, y: 225 },
            { note: "A♭", pc: tonnetzNoteToPc["A♭"], x: 360, y: 225 },
        ];


        // Explanations for operations
        // *** ESTA ES LA SECCIÓN ACTUALIZADA ***
        const explanations = {
            "L": "La operación **L (Leittonechel)** conecta tríadas que comparten la 3ra menor. <br><br>" +
                 "<strong>De Mayor a Menor:</strong> Transforma la 3ra mayor en una 4ta justa. La fundamental del acorde mayor desciende medio tono para convertirse en la 5ta del acorde menor (Ej: DoM [C, E, G] → Mim [E, G, B]).<br><br>" +
                 "<strong>De Menor a Mayor:</strong> Transforma la 3ra mayor en una 4ta justa. La 5ta del acorde menor asciende medio tono para convertirse en la fundamental del acorde mayor (Ej: Mim [E, G, B] → DoM [C, E, G]).",
            
            "P": "La operación **P (Parallel)** transforma una tríada en su paralela (mayor/menor) con la misma fundamental. Conserva la tónica y la 5ta justa, y desplaza la 3ra (mediante) un semitono.<br><br>" +
                 "<strong>De Mayor a Menor:</strong> La 3ra mayor desciende un semitono (Ej: DoM [C, E, G] → Dom [C, E♭, G]).<br><br>" +
                 "<strong>De Menor a Mayor:</strong> La 3ra menor asciende un semitono (Ej: Dom [C, E♭, G] → DoM [C, E, G]).",

            "R": "La operación **R (Relative)** conecta una tríada con su relativa (mayor/menor). Conserva dos notas en común (ej. C y E en DoM/Lam). La nota restante se desplaza un tono completo.<br><br>" +
                 "<strong>De Mayor a Menor:</strong> La 5ta del acorde mayor asciende un tono (Ej: DoM [C, E, G] → Lam [A, C, E]).<br><br>" +
                 "<strong>De Menor a Mayor:</strong> La tónica del acorde menor desciende un tono (Ej: Lam [A, C, E] → DoM [C, E, G]).",

            "N": "La operación **N (Nebenverwandt)** conecta dos tríadas que comparten una nota. Las otras dos voces se mueven un semitono cada una (en total, un tono).<br><br>" +
                 "<strong>De Mayor a Menor:</strong> Se invierte alrededor de la fundamental. Las notas 3ra y 5ta ascienden un semitono (Ej: DoM [C, E, G] → Fam [F, A♭, C]).<br><br>" +
                 "<strong>De Menor a Mayor:</strong> Se invierte alrededor de la 5ta. Las notas tónica y 3ra descienden un semitono (Ej: Fam [F, A♭, C] → DoM [C, E, G]).",

            "H": "La operación **H (Polo Hexatónico)** es una operación compuesta (PLP o LPL). Conecta los dos acordes más lejanos dentro de un ciclo hexatónico, los cuales no comparten <strong>ninguna</strong> nota en común.<br><br>" +
                 "Todas las voces se desplazan un semitono (Ej: DoM [C, E, G] → Sol♯m [G♯, B, D♯] o La♭m [A♭, C♭, E♭]).",

            "S": "La operación **S (Slide / Deslizamiento)** es una operación compuesta (RNR o NRN) que conecta dos acordes de diferente modo que comparten la 3ra.<br><br>" +
                 "<strong>De Mayor a Menor:</strong> Conserva la 3ra. La tónica y la 5ta se desplazan un semitono hacia arriba (Ej: DoM [C, E, G] → Do♯m [C♯, E, G♯]).<br><br>" +
                 "<strong>De Menor a Mayor:</strong> Conserva la 3ra. La tónica y la 5ta se desplazan un semitono hacia abajo (Ej: Do♯m [C♯, E, G♯] → DoM [C, E, G])."
        };
        // *** FIN DE LA SECCIÓN ACTUALIZADA ***

        // Function to display operation explanation
        function displayOperationExplanation(opCode) {
            operationExplanation.innerHTML = explanations[opCode] || "Selecciona una operación para ver su descripción.";
        }

        // Function to show the author modal
        function showAuthorModal() {
            if (!hasModalBeenShown) {
                authorModal.classList.add('show');
                setTimeout(() => {
                    authorModal.classList.remove('show');
                }, 4000); // Hide after 4 seconds
                hasModalBeenShown = true; // Set flag to true after showing
            }
        }

        // Helper to draw a line in SVG
        function drawLine(svg, p1, p2, color, strokeWidth = "1") {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", p1.x);
            line.setAttribute("y1", p1.y);
            line.setAttribute("x2", p2.x);
            line.setAttribute("y2", p2.y);
            line.setAttribute("stroke", color);
            line.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(line);
        }

        function drawFullTonnetz() {
            tonnetzSvg.innerHTML = ''; // Clear existing content

            // Create a map for quick lookup by coordinates
            coordToNodeMap = new Map(); // Re-initialize global map
            tonnetzNodesData.forEach(node => {
                coordToNodeMap.set(`${node.x},${node.y}`, node);
            });

            // Draw connections first (lines)
            tonnetzNodesData.forEach(node => {
                // Check for P5 right neighbor (horizontal)
                const p5RightCoord = `${node.x + P5_HORIZONTAL_SPACING},${node.y}`;
                const p5RightNode = coordToNodeMap.get(p5RightCoord);
                if (p5RightNode) {
                    drawLine(tonnetzSvg, node, p5RightNode, "#cbd5e1");
                }

                // Check for M3 up-right neighbor (diagonal)
                const m3UpRightCoord = `${node.x + THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`;
                const m3UpRightNode = coordToNodeMap.get(m3UpRightCoord);
                if (m3UpRightNode) {
                    drawLine(tonnetzSvg, node, m3UpRightNode, "#cbd5e1");
                }

                // Check for m3 up-left neighbor (diagonal)
                const m3UpLeftCoord = `${node.x - THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`;
                const m3UpLeftNode = coordToNodeMap.get(m3UpLeftCoord);
                if (m3UpLeftNode) {
                    drawLine(tonnetzSvg, node, m3UpLeftNode, "#cbd5e1");
                }
            });

            // Draw nodes (circles and text) on top of lines
            tonnetzNodesData.forEach(pos => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", pos.x);
                circle.setAttribute("cy", pos.y);
                circle.setAttribute("r", 15);
                circle.setAttribute("fill", "#e2e8f0");
                circle.setAttribute("stroke", "#94a3b8");
                circle.setAttribute("stroke-width", "1");
                circle.classList.add("tonnetz-node-circle"); // Renamed class
                circle.dataset.note = pos.note; // Store the exact note name for highlighting

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", pos.x);
                text.setAttribute("y", pos.y + 5);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-size", "10");
                text.setAttribute("fill", "#475569");
                text.textContent = pos.note; // Use the exact note name from tonnetzNodesData
                text.classList.add("tonnetz-node-text");
                text.dataset.note = pos.note;

                tonnetzSvg.appendChild(circle);
                tonnetzSvg.appendChild(text);
            });

            // Update viewBox to fit the generated content
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            tonnetzNodesData.forEach(node => {
                minX = Math.min(minX, node.x - 15); // Node radius
                minY = Math.min(minY, node.y - 15);
                maxX = Math.max(maxX, node.x + 15);
                maxY = Math.max(maxY, node.y + 15);
            });
            const padding = 20; // Extra padding for the viewBox
            const finalWidth = maxX - minX + 2 * padding;
            const finalHeight = maxY - minY + 2 * padding;
            tonnetzSvg.setAttribute("viewBox", `${minX - padding} ${minY - padding} ${finalWidth} ${finalHeight}`);
        }


        // Update highlightTonnetzTriad to use the new tonnetzGrid
        function highlightTonnetzTriad(triad) {
            // Remove existing highlights
            tonnetzSvg.querySelectorAll('.tonnetz-node-circle.active').forEach(node => node.classList.remove('active'));
            tonnetzSvg.querySelectorAll('.tonnetz-node-text.active').forEach(node => node.classList.remove('active'));
            tonnetzSvg.querySelectorAll('.tonnetz-triad-fill').forEach(fill => fill.remove()); // Remove dynamic fill

            const triadPcs = triad.pitchClasses; // These are 0-11 pitch classes

            // Highlight nodes that match the triad's pitch classes (reverted to previous behavior)
            triadPcs.forEach(pc => {
                // Find all notes in tonnetzNodesData that have this pitch class
                const matchingTonnetzNodes = tonnetzNodesData.filter(node => node.pc === pc);

                matchingTonnetzNodes.forEach(tonnetzNode => {
                    tonnetzSvg.querySelectorAll(`.tonnetz-node-circle[data-note="${tonnetzNode.note}"]`).forEach(node => node.classList.add('active'));
                    tonnetzSvg.querySelectorAll(`.tonnetz-node-text[data-note="${tonnetzNode.note}"]`).forEach(node => node.classList.add('active'));
                });
            });

            // Draw and highlight the triad triangle
            const rootPc = triad.pitchClasses[0];
            const thirdPc = triad.pitchClasses[1];
            const fifthPc = triad.pitchClasses[2];

            let foundTriadNodes = [];

            // Iterate through all nodes that match the root's pitch class to find the correct triangle
            const possibleRootNodes = tonnetzNodesData.filter(node => node.pc === rootPc);

            for (const pRootNode of possibleRootNodes) {
                let pThirdNode = null;
                let pFifthNode = null;

                if (triad.type === "major") {
                    // Expected Major Third position (up-right)
                    const m3UpRightCoord = `${pRootNode.x + THIRD_HORIZONTAL_OFFSET},${pRootNode.y - THIRD_VERTICAL_SPACING}`;
                    pThirdNode = coordToNodeMap.get(m3UpRightCoord);
                    // Expected Perfect Fifth position (right)
                    const p5RightCoord = `${pRootNode.x + P5_HORIZONTAL_SPACING},${pRootNode.y}`;
                    pFifthNode = coordToNodeMap.get(p5RightCoord);
                } else { // minor
                    // Expected Minor Third position (up-left)
                    const m3UpLeftCoord = `${pRootNode.x - THIRD_HORIZONTAL_OFFSET},${pRootNode.y - THIRD_VERTICAL_SPACING}`;
                    pThirdNode = coordToNodeMap.get(m3UpLeftCoord);
                    // Expected Perfect Fifth position (right)
                    const p5RightCoord = `${pRootNode.x + P5_HORIZONTAL_SPACING},${pRootNode.y}`;
                    pFifthNode = coordToNodeMap.get(p5RightCoord);
                }

                // Check if the found nodes exist and have the correct pitch classes
                if (pThirdNode && pFifthNode &&
                    pThirdNode.pc === thirdPc && pFifthNode.pc === fifthPc) {
                    foundTriadNodes = [pRootNode, pThirdNode, pFifthNode];
                    break; // Found the correct set of nodes for the triangle
                }
            }

            if (foundTriadNodes.length === 3) {
                const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                // Sort coords by x then y to ensure consistent drawing order for polygon
                foundTriadNodes.sort((a, b) => {
                    if (a.x !== b.x) return a.x - b.x;
                    return a.y - b.y;
                });
                polygon.setAttribute("points", `${foundTriadNodes[0].x},${foundTriadNodes[0].y} ${foundTriadNodes[1].x},${foundTriadNodes[1].y} ${foundTriadNodes[2].x},${foundTriadNodes[2].y}`);
                polygon.setAttribute("fill", triad.type === 'major' ? "rgba(255, 0, 0, 0.4)" : "rgba(0, 0, 255, 0.4)"); // Red for major, blue for minor, slightly more opaque
                polygon.setAttribute("stroke", triad.type === 'major' ? "red" : "blue");
                polygon.setAttribute("stroke-width", "3");
                polygon.classList.add("tonnetz-triad-fill");
                tonnetzSvg.prepend(polygon); // Add to the beginning so it's behind notes/lines
            }
        }


        // Populate initial chord options
        function populateStartChordSelect() {
            // Define a canonical order for roots in the dropdown
            const orderedRoots = [
                "C", "D♭", "D", "E♭", "E", "F", "F♯", "G", "A♭", "A", "B♭", "B"
            ];
            
            // Create a temporary list of triads to populate the dropdown, ensuring no duplicates
            const dropdownTriads = [];
            const addedNames = new Set(); // To track names already added

            // Iterate through the ordered roots to ensure consistent dropdown order
            orderedRoots.forEach(rootName => {
                // Find major and minor triads for this root
                const majorTriad = allTriads.find(t => t.root === rootName && t.type === "major");
                const minorTriad = allTriads.find(t => t.root === rootName && t.type === "minor");

                if (majorTriad && !addedNames.has(majorTriad.name)) {
                    dropdownTriads.push(majorTriad);
                    addedNames.add(majorTriad.name);
                }
                if (minorTriad && !addedNames.has(minorTriad.name)) {
                    dropdownTriads.push(minorTriad);
                    addedNames.add(minorTriad.name);
                }
            });

            // Sort the final list for the dropdown
            const sortedDropdownTriads = [...dropdownTriads].sort((a, b) => {
                const indexA = orderedRoots.indexOf(a.root);
                const indexB = orderedRoots.indexOf(b.root);

                if (indexA !== indexB) {
                    return indexA - indexB;
                }
                return a.type.localeCompare(b.type); // Major before minor
            });

            sortedDropdownTriads.forEach(triad => {
                const option = document.createElement("option");
                option.value = triad.name;
                option.textContent = triad.name;
                startChordSelect.appendChild(option);
            });
            startChordSelect.value = "C Mayor";
        }

        // Initialize or reset the application state
        function initializeApp() {
            try {
                const selectedTriadName = startChordSelect.value;
                currentTriad = allTriads.find(t => t.name === selectedTriadName);
                if (!currentTriad) {
                    console.error("Error: Initial triad not found for name:", selectedTriadName);
                    // Fallback to a default if the selected one is not found
                    currentTriad = getTriadByName("C Mayor");
                    if (!currentTriad) {
                        console.error("Critical Error: C Mayor not found. Cannot initialize.");
                        document.body.innerHTML = "<p style='color: red; text-align: center; margin-top: 50px;'>Error crítico al cargar la aplicación. Por favor, recarga.</p>";
                        return;
                    }
                }
                history = [];

                // NUEVO: Inicializar el lastPlayedVoicing
                const rootNotes = currentTriad.getNotes();
                const toneNotes = rootNotes.map(n => `${n.replace('♯', '#').replace('♭', 'b')}4`);
                lastPlayedVoicing = toneNotes; // Inicializa en la 4ª octava

                updateUI();
                updateCircleVisualization(currentTriad); // Llamada a la nueva función
                displayOperationExplanation(''); // Clear explanation on reset
                removeActiveOperationHighlight(); // Clear any highlighted operation button
                removeOperationsBoxHighlight(); // Clear operations box highlight
                
                // Only show modal if it hasn't been shown before (first page load)
                showAuthorModal(); 

            } catch (error) {
                console.error("Error during application initialization:", error);
                document.body.innerHTML = "<p style='color: red; text-align: center; margin-top: 50px;'>Ha ocurrido un error al cargar la aplicación. Por favor, inténtalo de nuevo.</p>";
            }
        }

        // Update the UI with current triad information
        function updateUI() {
            currentChordName.textContent = currentTriad.name;
            const notes = currentTriad.getNotes();
            currentChordNotes.innerHTML = `Raíz: <span class="font-bold">${notes[0]}</span>, Tercera: <span class="font-bold">${notes[1]}</span>, Quinta: <span class="font-bold">${notes[2]}</span>`;
            updateHistoryLog();
            highlightCircleNode(currentTriad); // Renombrada
            updateSetRelationshipsDisplay();
            highlightTonnetzTriad(currentTriad); // Call to update the new Tonnetz visualization
        }

        // Add an entry to the history log
        function addHistoryEntry(operationName, oldTriad, newTriad) {
            const entry = {
                operation: operationName,
                from: oldTriad.name,
                to: newTriad.name,
                timestamp: new Date().toLocaleTimeString()
            };
            history.push(entry);
            historyLog.scrollTop = historyLog.scrollHeight;
        }

        // Render the history log
        function updateHistoryLog() {
            historyLog.innerHTML = "";
            if (history.length === 0) {
                historyLog.innerHTML = "<p class='text-gray-500'>No hay transformaciones aún.</p>";
                return;
            }
            history.forEach(entry => {
                const div = document.createElement("div");
                div.className = "history-item";
                div.textContent = `${entry.timestamp}: ${entry.from} --(${entry.operation})--> ${entry.to}`;
                historyLog.appendChild(div);
            });
        }

        // Helper to find a triad by its pitch classes (for operations that might generate new note names)
        function findTriadByPitchClasses(pcs, type) {
            const sortedPcs = [...pcs].sort();
            for (const triad of allTriads) {
                const sortedTriadPcs = [...triad.pitchClasses].sort();
                if (triad.type === type && sortedPcs.every((pc, i) => pc === sortedTriadPcs[i])) {
                    return triad;
                }
            }
            // Fallback: Si no se encuentra una coincidencia exacta de nombre, buscar enarmónicamente.
            for (const root of canonicalSpelling) {
                const testTriad = new Triad(root, type);
                const sortedTestPcs = [...testTriad.pitchClasses].sort();
                if (sortedTestPcs.every((pc, i) => pc === sortedPcs[i])) {
                    // Encontramos una coincidencia enarmónica, la añadimos a nuestra lista si no está
                    if (!allTriads.find(t => t.name === testTriad.name)) {
                        allTriads.push(testTriad);
                    }
                    return testTriad;
                }
            }
            console.warn("Could not find matching triad for pcs:", pcs, "type:", type);
            return null;
        }

        // --- Set Relationship Functions ---
        function getHexatonicCycleForTriad(triad) {
            for (const cycle of hexatonicCycles) {
                if (cycle.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return cycle;
                }
            }
            return null;
        }
        
        function getWeitzmannCycleForTriad(triad) {
            // Usamos las regiones predefinidas para encontrar a cuál pertenece
            const region = getWeitzmannRegionForTriad(triad);
            if (!region) return null;
            // Hacemos coincidir por nombre (p.ej. "Región de C-E-G♯" -> "Región I (C-E-G♯)")
            const regionNotes = region.name.split(' ')[2]; // "C-E-G♯"
            return weitzmannCycles.find(cycle => cycle.name.includes(regionNotes));
        }

        function getWeitzmannRegionForTriad(triad) {
            for (const region of weitzmannRegions) {
                if (region.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return region;
                }
            }
            return null;
        }

        function updateSetRelationshipsDisplay() {
            const hexCycle = getHexatonicCycleForTriad(currentTriad);
            const weitzRegion = getWeitzmannRegionForTriad(currentTriad); 

            // Helper function to create the span
            const createChordSpan = (triad, baseClasses) => {
                // Añadimos clases de cursor y transformación, y el atributo data-chord-name
                return `<span class="${baseClasses} px-2 py-1 rounded-md cursor-pointer transform transition-transform hover:scale-105" data-chord-name="${triad.name}">${triad.name}</span>`;
            };

            if (hexCycle) {
                currentHexatonicCycleSpan.textContent = hexCycle.name;
                hexatonicCycleMembersDiv.innerHTML = hexCycle.members.map(t => createChordSpan(t, 'bg-blue-100 text-blue-800')).join('');
            } else {
                currentHexatonicCycleSpan.textContent = "No encontrado";
                hexatonicCycleMembersDiv.innerHTML = "";
            }

            if (weitzRegion) {
                currentWeitzmannRegionSpan.textContent = weitzRegion.name;
                weitzmannRegionMembersDiv.innerHTML = weitzRegion.members.map(t => createChordSpan(t, 'bg-green-100 text-green-800')).join('');
            } else {
                currentWeitzmannRegionSpan.textContent = "No encontrado";
                weitzmannRegionMembersDiv.innerHTML = "";
            }

            if (hexCycle && weitzRegion) {
                const shared = hexCycle.members.filter(hexMember =>
                    weitzRegion.members.some(weitzMember => weitzMember.hasSamePitchClasses(hexMember) && weitzMember.type === hexMember.type)
                );
                sharedChordsDiv.innerHTML = shared.map(t => createChordSpan(t, 'bg-purple-100 text-purple-800')).join('');
            } else {
                sharedChordsDiv.innerHTML = "<p class='text-gray-500'>No hay conjuntos para comparar.</p>";
            }
        }


        // --- Circle Visualization (Refactored) ---

        // Función principal que decide qué círculo dibujar
        function updateCircleVisualization(activeTriad) {
            let foundCycle;
            if (currentVisualizationMode === 'hexatonic') {
                circleTitle.textContent = "Visualización (Ciclo L/P)";
                circleDescription.textContent = "Ciclo Hexatónico (L/P). Las operaciones R, N y S pueden llevarte a un ciclo diferente.";
                foundCycle = getHexatonicCycleForTriad(activeTriad);
                drawCircle(activeTriad, foundCycle, 'L', 'P');
            } else { // 'weitzmann'
                circleTitle.textContent = "Visualización (Ciclo R/N)";
                circleDescription.textContent = "Región de Weitzmann (R/N). Las operaciones L, P y H pueden llevarte a un ciclo diferente.";
                foundCycle = getWeitzmannCycleForTriad(activeTriad);
                drawCircle(activeTriad, foundCycle, 'R', 'N');
            }
        }

        // Función genérica para dibujar cualquier círculo
        function drawCircle(activeTriad, foundCycle, op1Name, op2Name) {
            hexatonicCircleSvg.innerHTML = `<defs>
                                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                                    <polygon points="0 0, 10 3.5, 0 7" />
                                                </marker>
                                            </defs>`;

            if (!foundCycle) {
                hexatonicCircleSvg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#64748b" class="text-xs">El acorde actual no está en este tipo de ciclo.</text>`;
                currentCircleChords = [];
                return;
            }

            currentCircleChords = foundCycle.members;

            const centerX = 150;
            const centerY = 150;
            const radius = 120;
            const nodeWidth = 60;
            const nodeHeight = 30;

            const op1Func = (triad) => (op1Name === 'L' ? opL(triad) : opR(triad));
            const op2Func = (triad) => (op2Name === 'P' ? opP(triad) : opN(triad));

            currentCircleChords.forEach((triad, index) => {
                const angle = (index * (360 / currentCircleChords.length) - 90) * Math.PI / 180;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const node = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                node.setAttribute("x", x - nodeWidth / 2);
                node.setAttribute("y", y - nodeHeight / 2);
                node.setAttribute("width", nodeWidth);
                node.setAttribute("height", nodeHeight);
                node.classList.add("chord-node");
                if (triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type) {
                    node.classList.add("active");
                }
                node.innerHTML = `<div class="w-full h-full flex items-center justify-center">${triad.name}</div>`;
                hexatonicCircleSvg.appendChild(node);

                node.addEventListener('click', () => {
                    currentTriad = getTriadByName(triad.name);
                    history = [];
                    updateUI();
                    updateCircleVisualization(currentTriad); // Llamada a la función principal
                    displayOperationExplanation('');
                    removeActiveOperationHighlight();
                    removeOperationsBoxHighlight();
                });

                const nextIndex = (index + 1) % currentCircleChords.length;
                const nextTriad = currentCircleChords[nextIndex];

                const nextAngle = (nextIndex * (360 / currentCircleChords.length) - 90) * Math.PI / 180;
                const nextX = centerX + radius * Math.cos(nextAngle);
                const nextY = centerY + radius * Math.sin(nextAngle);

                let isArrowActive = false;
                if (triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type) {
                    let expectedNext;
                    if (index % 2 === 0) { // Aplicar op1
                        expectedNext = op1Func(triad);
                    } else { // Aplicar op2
                        expectedNext = op2Func(triad);
                    }

                    if (expectedNext && expectedNext.hasSamePitchClasses(nextTriad) && expectedNext.type === nextTriad.type) {
                        isArrowActive = true;
                    }
                }

                drawArrow(hexatonicCircleSvg, x, y, nextX, nextY, nodeWidth / 2, isArrowActive);
            });
        }

        function drawArrow(svg, x1, y1, x2, y2, offset, isActive = false) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const startX = x1 + offset * Math.cos(angle);
            const startY = y1 + offset * Math.sin(angle);
            const endX = x2 - offset * Math.sin(angle);
            const endY = y2 - offset * Math.sin(angle);

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", `M ${startX} ${startY} L ${endX} ${endY}`);
            path.setAttribute("class", `arrow ${isActive ? 'arrow-active' : ''}`);
            svg.appendChild(path);
        }

        function highlightCircleNode(triadToHighlight) { // Renombrada
            document.querySelectorAll('.chord-node').forEach(node => {
                node.classList.remove('active');
            });
            const index = currentCircleChords.findIndex(t => t.hasSamePitchClasses(triadToHighlight) && t.type === triadToHighlight.type);
            if (index !== -1) {
                const nodeElement = hexatonicCircleSvg.children[index + 1]; // +1 para saltar <defs>
                if (nodeElement) {
                    nodeElement.classList.add('active');
                }
            }
        }

        // Function to highlight the active operation button
        function highlightActiveOperation(opCode) {
            removeActiveOperationHighlight();
            const button = document.querySelector(`[data-op="${opCode}"]`);
            if (button) {
                button.classList.add('active-op-btn');
            }
            highlightOperationsBox();
        }

        // Function to remove all active operation button highlights
        function removeActiveOperationHighlight() {
            operationButtons.forEach(button => {
                button.classList.remove('active-op-btn');
            });
        }

        // Function to highlight the operations box
        function highlightOperationsBox() {
            operationsBox.classList.add('operations-box-active');
        }

        // Function to remove operations box highlight
        function removeOperationsBoxHighlight() {
            operationsBox.classList.remove('operations-box-active');
        }


        // Event Listeners
        resetButton.addEventListener("click", initializeApp);

        playChordButton.addEventListener('click', () => {
            // Reproduce el último voicing guardado
            const midiNotes = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            playVoicing(midiNotes);
        });

        document.getElementById("opL").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opL(currentTriad);

            // NUEVO: Calcular y reproducir voicing
            const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            const newMidiVoicing = getClosestVoicing(fromMidi, currentTriad);
            playVoicing(newMidiVoicing);

            addHistoryEntry("L", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("L");
            updateCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opP").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opP(currentTriad);

            // NUEVO: Calcular y reproducir voicing
            const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            const newMidiVoicing = getClosestVoicing(fromMidi, currentTriad);
            playVoicing(newMidiVoicing);

            addHistoryEntry("P", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("P");
            updateCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opR").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opR(currentTriad);

            // NUEVO: Calcular y reproducir voicing
            const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            const newMidiVoicing = getClosestVoicing(fromMidi, currentTriad);
            playVoicing(newMidiVoicing);

            addHistoryEntry("R", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("R");
            updateCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opN").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opN(currentTriad);

            // NUEVO: Calcular y reproducir voicing
            const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            const newMidiVoicing = getClosestVoicing(fromMidi, currentTriad);
            playVoicing(newMidiVoicing);

            addHistoryEntry("N", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("N");
            updateCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opH").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opH(currentTriad);

            // NUEVO: Calcular y reproducir voicing
            const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            const newMidiVoicing = getClosestVoicing(fromMidi, currentTriad);
            playVoicing(newMidiVoicing);

            addHistoryEntry("H", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("H");
            updateCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opS").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opS(currentTriad);

            // NUEVO: Calcular y reproducir voicing
            const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            const newMidiVoicing = getClosestVoicing(fromMidi, currentTriad);
            playVoicing(newMidiVoicing);

            addHistoryEntry("S", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("S");
            updateCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });
        
        // --- Listener para el Toggle Switch ---
        vizToggle.addEventListener('change', (event) => {
            currentVisualizationMode = event.target.checked ? 'weitzmann' : 'hexatonic';
            updateCircleVisualization(currentTriad);
        });

        // --- Listeners para el Glosario ---
        glossaryButton.addEventListener('click', () => {
            glossaryModal.classList.add('show');
        });

        closeGlossaryButton.addEventListener('click', () => {
            glossaryModal.classList.remove('show');
        });

        // Clic fuera del modal para cerrarlo
        glossaryModal.addEventListener('click', (event) => {
            if (event.target === glossaryModal) {
                glossaryModal.classList.remove('show');
            }
        });

        // Clic fuera del modal para cerrarlo
        glossaryModal.addEventListener('click', (event) => {
            if (event.target === glossaryModal) {
                glossaryModal.classList.remove('show');
            }
        });

        // --- Listener para los acordes en "Relación entre Conjuntos" ---
        setRelationshipsDiv.addEventListener('click', (event) => {
            // Usamos .closest() para asegurarnos de capturar el span aunque se haga clic en su texto interno
            const clickedSpan = event.target.closest('[data-chord-name]');
            if (!clickedSpan) return; // No se hizo clic en un acorde

            const chordName = clickedSpan.dataset.chordName;
            const triadToPlay = getTriadByName(chordName);

            if (triadToPlay && triadToPlay.name !== currentTriad.name) { // No hacer nada si se hace clic en el mismo acorde
                startAudioContext(); 
                
                // 1. Calcular y reproducir nuevo voicing
                const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                const newMidiVoicing = getClosestVoicing(fromMidi, triadToPlay);
                playVoicing(newMidiVoicing); // Esto reproduce Y actualiza lastPlayedVoicing
                
                // 2. Actualizar el estado global para reflejar el cambio
                const oldTriad = currentTriad;
                currentTriad = triadToPlay;
                
                // 3. Actualizar toda la UI
                addHistoryEntry("Click", oldTriad, currentTriad); // Añadir al historial
                updateUI(); // Actualizar nombre de acorde, notas, historial, etc.
                updateCircleVisualization(currentTriad); // Actualizar el círculo
                displayOperationExplanation(''); // Limpiar explicación
                removeActiveOperationHighlight(); // Limpiar botón de operación
                removeOperationsBoxHighlight(); // Limpiar caja de operación
            
            } else if (triadToPlay && triadToPlay.name === currentTriad.name) {
                // Si se hace clic en el acorde ya activo, simplemente reproducirlo de nuevo
                startAudioContext();
                const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                playVoicing(fromMidi);
            }
        });

        // Initial setup on page load
        window.onload = () => {
            populateStartChordSelect();
            initializeApp();
            drawFullTonnetz(); // Draw the new dynamic Tonnetz visualization
        };
    </script>
</body>
</html>
