<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Teoría Neo-Riemanniana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Incluir Tone.js para Web Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Fondo gris-azulado claro */
            color: #334155; /* Texto oscuro */
        }
        .container {
            max-width: 1200px; /* Ampliado para la nueva visualización */
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn {
            @apply px-4 py-2 rounded-lg font-semibold transition-all duration-200 cursor-pointer;
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 shadow-lg transform hover:scale-105;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 shadow-md transform hover:scale-105;
        }
        /* Estilo para botones deshabilitados */
        .btn:disabled {
            @apply bg-gray-300 text-gray-500 cursor-not-allowed transform-none shadow-none hover:bg-gray-300;
        }

        /* Estilo para el botón de operación activo */
        .btn-secondary.active-op-btn {
            @apply bg-yellow-400 text-gray-900 border-2 border-yellow-600 shadow-xl transform scale-105;
        }

        /* Estilo para la caja de operaciones */
        #operationsBox {
            transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
        }
        #operationsBox.operations-box-active {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5), 0 10px 20px -5px rgba(59, 130, 246, 0.3); /* Resplandor azul */
            border-color: #3b82f6; /* Borde más brillante */
        }

        .chord-display {
            @apply bg-blue-100 p-4 rounded-lg text-center my-4 border border-blue-200 transition-all duration-150;
            cursor: pointer; /* AÑADIDO: Indica que se puede hacer clic */
        }
        .chord-display:hover {
            @apply bg-blue-200; /* AÑADIDO: Efecto hover */
        }

        .history-item {
            @apply bg-gray-50 p-2 rounded-md mb-2 text-sm border border-gray-100;
        }
        .explanation-box {
            @apply bg-green-50 p-4 rounded-lg text-sm my-4 border border-green-100;
        }
        /* Estilos para la visualización circular */
        .circle-container {
            position: relative;
            margin: 0 auto;
            border: 2px solid #cbd5e1;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8fafc; /* Fondo más claro para el círculo */
            width: 100%; /* Rellenar el ancho del padre */
            height: 100%; /* Rellenar la altura del padre */
        }
        .chord-node {
            position: absolute;
            width: 60px;
            height: 30px;
            background-color: #e2e8f0;
            border: 1px solid #94a3b8;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s ease-in-out, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chord-node.active {
            background-color: #3b82f6;
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 6px 12px -2px rgba(59, 130, 246, 0.4), 0 3px 7px -3px rgba(59, 130, 246, 0.3);
            animation: pulse 1.5s infinite alternate; /* Efecto de pulso sutil */
        }
        /* Acorde "fantasma" anterior */
        .chord-node.previous-active {
            background-color: #94a3b8; /* Gris */
            color: #e2e8f0;
            border-color: #64748b;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            opacity: 0.7;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.03); }
        }

        .arrow {
            position: absolute;
            stroke: #94a3b8; /* Gris más claro para las flechas por defecto */
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .arrow-active {
            stroke: #3b82f6;
            stroke-width: 3;
        }
        #arrowhead {
            fill: #94a3b8;
        }
        .arrow-active #arrowhead {
            fill: #3b82f6;
        }

        /* Ajustes responsivos */
        @media (max-width: 640px) {
            .container {
                margin: 1rem;
                padding: 1rem;
            }
            .chord-node {
                width: 50px;
                height: 25px;
                font-size: 0.65rem;
            }
            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.875rem;
            }
        }

        /* Estilos del Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.2), 0 8px 15px -5px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px; /* Ancho del modal de glosario */
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
            max-height: 80vh; /* Altura máxima */
            overflow-y: auto; /* Scroll si el contenido es muy largo */
        }
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        /* Estilos del interruptor (toggle) */
        .toggle-switch-container {
            @apply flex items-center justify-center space-x-2 my-2;
        }
        .toggle-switch-label {
            @apply text-sm font-medium text-gray-700;
        }
        .toggle-switch {
            @apply relative inline-block w-10 h-6;
        }
        .toggle-switch-input {
            @apply opacity-0 w-0 h-0;
        }
        .toggle-switch-slider {
            @apply absolute cursor-pointer top-0 left-0 right-0 bottom-0 bg-gray-300 rounded-full transition-all;
        }
        .toggle-switch-slider:before {
            @apply absolute content-[''] h-4 w-4 left-1 bottom-1 bg-white rounded-full transition-all;
        }
        .toggle-switch-input:checked + .toggle-switch-slider {
            @apply bg-blue-600;
        }
        .toggle-switch-input:checked + .toggle-switch-slider:before {
            transform: translateX(16px);
        }

        /* Estilos de las pestañas de visualización */
        .viz-tab-container {
            @apply flex border-b border-gray-300 mb-4;
        }
        .viz-tab-btn {
            @apply px-4 py-2 -mb-px font-semibold text-gray-600 border-b-2 border-transparent hover:text-blue-600 hover:border-blue-600;
        }
        .viz-tab-btn.active {
            @apply text-blue-600 border-blue-600;
        }
        .viz-pane {
            @apply hidden; /* Oculto por defecto */
        }
        .viz-pane.active {
            @apply block; /* Visible cuando está activo */
        }
        
        /* Estilos de visualización del Tonnetz */
        .tonnetz-node-circle {
            transition: fill 0.2s ease-in-out, stroke 0.2s ease-in-out;
        }
        .tonnetz-node-circle.active {
            fill: #3b82f6;
            stroke: #1d4ed8;
            stroke-width: 2px;
        }
        .tonnetz-node-circle.previous-active {
            fill: #94a3b8;
            stroke: #64748b;
            stroke-width: 1px;
            opacity: 0.7;
        }
        .tonnetz-node-text {
            transition: fill 0.2s ease-in-out;
        }
        .tonnetz-node-text.active {
            fill: white;
            font-weight: bold;
        }
        .tonnetz-node-text.previous-active {
            fill: #e2e8f0;
            opacity: 0.7;
        }
        .tonnetz-triad-fill {
            transition: fill 0.2s ease-in-out;
            opacity: 0.4;
        }
        .tonnetz-triad-fill.active {
            fill: #3b82f6; /* Azul para el acorde activo */
        }
        .tonnetz-triad-fill.previous-active {
            fill: #94a3b8; /* Gris para el acorde anterior */
            opacity: 0.3;
        }

        /* Flecha de transformación en Tonnetz */
        .tonnetz-transformation-path {
            stroke: #3b82f6;
            stroke-width: 3;
            fill: none;
            marker-end: url(#arrowhead-tonnetz); /* ID de marcador específico de Tonnetz */
            opacity: 0;
            animation: drawTonnetzPath 1s ease-out forwards;
        }
        @keyframes drawTonnetzPath {
            0% {
                stroke-dasharray: 500;
                stroke-dashoffset: 500;
                opacity: 1;
            }
            70% {
                stroke-dasharray: 500;
                stroke-dashoffset: 0;
                opacity: 1;
            }
            100% {
                stroke-dasharray: 500;
                stroke-dashoffset: 0;
                opacity: 0;
            }
        }

        /* Nuevos estilos para resaltar botones de operación */
        .btn-op-highlight-lp {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); /* Resplandor azul (L/P) */
            border-color: #3b82f6;
        }
        .btn-op-highlight-rn {
            box-shadow: 0 0 0 3px rgba(22, 163, 74, 0.5); /* Resplandor verde (R/N) */
            border-color: #16a34a;
        }

        /* Estilos para el nuevo módulo de análisis */
        .analysis-explanation-box {
            @apply bg-yellow-50 p-4 rounded-lg text-sm my-4 border border-yellow-200 text-gray-800;
        }
        
        /* ESTILOS CORREGIDOS para el marcador de la partitura */
        .analysis-score-container {
            @apply relative w-full mb-4; /* Contenedor para el posicionamiento absoluto */
        }
        .analysis-score-image {
            @apply w-full rounded-lg border-2 border-gray-300 shadow-md;
        }
        #analysisScoreMarker {
            @apply absolute border-4 border-red-500 rounded-md transition-all duration-500 ease-in-out;
            background-color: rgba(239, 68, 68, 0.3); /* Fondo rojo más visible (30%) */
            pointer-events: none; /* Para que no interfiera con clics */
            opacity: 0; /* Oculto por defecto */
        }
        #analysisScoreMarker.show {
            opacity: 1;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-blue-700">Explorador de Teoría Neo-Riemanniana</h1>
        <p class="text-gray-700 mb-6 text-center">
            Bienvenido a este entorno interactivo para explorar las operaciones de la Teoría Neo-Riemanniana.
            Selecciona un acorde inicial y aplica las operaciones para ver cómo transforman las tríadas y cómo se relacionan en el espacio tonal cromático.
        </p>

        <div class="flex flex-col md:flex-row gap-6">
            <!-- Columna Izquierda: Controles -->
            <div class="md:w-1/2 flex flex-col">
                <div id="startChordContainer" class="mb-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <label for="startChord" class="block text-gray-700 text-sm font-bold mb-2">Selecciona un acorde inicial:</label>
                    <select id="startChord" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                        <!-- Opciones pobladas por JS -->
                    </select>
                    <div class="flex gap-3 mt-3">
                        <button id="resetButton" class="btn btn-primary w-1/2">Reiniciar</button>
                        <button id="glossaryButton" class="btn btn-secondary w-1/2">Glosario</button>
                    </div>
                </div>

                <!-- NUEVO: Módulo de Análisis Guiado -->
                <div class="mb-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <label for="analysisSelect" class="block text-gray-700 text-sm font-bold mb-2">Análisis Guiado (del PDF):</label>
                    <select id="analysisSelect" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                        <option value="">Selecciona un análisis...</option>
                        <option value="liszt">Liszt - Consolación IV</option>
                        <option value="schubert">Schubert - D.946 Nº2</option>
                    </select>
                </div>
                
                <!-- NUEVO: Controles de Análisis -->
                <div id="analysisControls" class="hidden mb-4 p-4 bg-yellow-50 rounded-lg shadow-inner border border-yellow-200">
                    <h3 class="text-lg font-semibold mb-2 text-gray-800">Análisis en Curso: <span id="analysisTitle"></span></h3>
                    
                    <!-- NUEVO: Contenedor para la imagen y el marcador -->
                    <div id="analysisScoreContainer" class="analysis-score-container hidden">
                        <img id="analysisScoreImage" src="" alt="Partitura del análisis" class="analysis-score-image">
                        <!-- NUEVO: Marcador -->
                        <div id="analysisScoreMarker"></div>
                    </div>
                    
                    <div id="analysisExplanation" class="analysis-explanation-box">
                        Selecciona un análisis para comenzar.
                    </div>

                    <!-- NUEVO: Cita del libro -->
                    <p class="text-xs text-gray-600 mt-3 mb-2 px-1">
                        Análisis y partituras extraídos de:
                        <br>
                        Calabrese, A. (2025). <i>Armonía de los siglos XIX al XXI: Claves para navegar el espacio cromático</i>. Ombú Ediciones Musicales.
                    </p>
                    
                    <div class="flex justify-between gap-3 mt-3">
                        <button id="prevStepBtn" class="btn btn-secondary w-1/3">Anterior</button>
                        <button id="nextStepBtn" class="btn btn-secondary w-1/3">Siguiente</button>
                        <button id="exitAnalysisBtn" class="btn btn-primary w-1/3">Salir</button>
                    </div>
                </div>
                <!-- FIN de Módulo de Análisis -->

                <!-- NUEVO: Módulo de Análisis Libre -->
                <div id="freeAnalysisContainer" class="mb-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <label for="freeAnalysisInput" class="block text-gray-700 text-sm font-bold mb-2">Análisis Libre</label>
                    <textarea id="freeAnalysisInput" rows="3" class="shadow-sm border border-gray-300 rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Escribe una progresión, ej: DoM, Lam, FaM, DoM"></textarea>
                    <button id="freeAnalysisButton" class="btn btn-primary w-full mt-3">Analizar Progresión</button>
                    <p id="freeAnalysisError" class="text-red-600 text-sm mt-2"></p>
                </div>
                <!-- FIN de Módulo de Análisis Libre -->

                <div class="chord-display">
                    <div class="flex justify-center items-center gap-2">
                        <h2 class="text-xl font-bold text-blue-800">Acorde Actual: <span id="currentChordName">C Mayor</span></h2>
                        <button id="playChordButton" class="btn btn-secondary p-2 leading-none">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-volume-up-fill" viewBox="0 0 16 16">
                                <path d="M11.536 14.01A8.47 8.47 0 0 0 14.026 8a8.47 8.47 0 0 0-2.49-6.01l-.707.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.198 5.303z"/>
                                <path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.483 5.483 0 0 1 11.025 8a5.483 5.483 0 0 1-1.61 3.89z"/>
                                <path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.489 3.489 0 0 1 8 10.475zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06"/>
                            </svg>
                        </button>
                    </div>
                    <p class="text-lg text-gray-700">Notas: <span id="currentChordNotes">C, E, G</span></p>
                </div>

                <div id="operationsBox" class="mb-4 p-4 bg-blue-50 rounded-lg shadow-inner border border-blue-100"> <!-- Caja coloreada para operaciones -->
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Operaciones:</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                        <button id="opL" class="btn btn-secondary" data-op="L">L (Leittonechel)</button>
                        <button id="opP" class="btn btn-secondary" data-op="P">P (Parallel)</button>
                        <button id="opR" class="btn btn-secondary" data-op="R">R (Relative)</button>
                        <button id="opN" class="btn btn-secondary" data-op="N">N (Next Related)</button>
                        <button id="opH" class="btn btn-secondary" data-op="H">H (Hexatonic Pole)</button>
                        <button id="opS" class="btn btn-secondary" data-op="S">S (Slide)</button>
                    </div>
                </div>

                <div class="explanation-box">
                    <h3 class="text-lg font-semibold mb-2 text-green-800">Explicación de la Operación:</h3>
                    <p id="operationExplanation" class="text-gray-800">Selecciona una operación para ver su descripción.</p>
                </div>

                <!-- Nueva Sección UI para Relaciones de Conjuntos -->
                <div class="p-4 bg-gray-50 rounded-lg shadow-inner mt-6">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Relación entre Conjuntos:</h3>
                    <div id="setRelationships" class="bg-white p-3 rounded-lg border border-gray-200">
                        <p class="mb-2"><strong class="text-blue-700">Ciclo Hexatónico Actual (L/P):</strong> <span id="currentHexatonicCycle"></span></p>
                        <div id="hexatonicCycleMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-green-700">Región de Weitzmann Actual (R/N):</strong> <span id="currentWeitzmannRegion"></span></p>
                        <div id="weitzmannRegionMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-purple-700">Acordes Compartidos:</strong></p>
                        <div id="sharedChords" class="flex flex-wrap gap-2 text-sm"></div>
                    </div>
                </div>

                <div class="p-4 bg-gray-50 rounded-lg shadow-inner mt-6 flex-grow">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Historial de Transformaciones:</h3>
                    <div id="historyLog" class="h-60 overflow-y-auto border border-gray-200 rounded-lg p-2 bg-white">
                        <!-- Items del historial se añadirán aquí -->
                    </div>
                </div>
            </div>

            <!-- Columna Derecha: Visualizaciones -->
            <div class="md:w-1/2 flex flex-col">
                <!-- Pestañas de Visualización -->
                <div class="viz-tab-container">
                    <button id="tabBtnCircle" class="viz-tab-btn active" data-viz="circle">Círculo</button>
                    <button id="tabBtnTonnetz" class="viz-tab-btn" data-viz="tonnetz">Tonnetz</button>
                </div>

                <!-- Panel de Visualización del Círculo -->
                <div id="vizPaneCircle" class="viz-pane active">
                    <div class="p-4 flex flex-col items-center justify-center bg-white rounded-lg shadow-inner border border-blue-100 h-[450px]">
                        <h3 id="circleTitle" class="text-lg font-semibold mb-3 text-gray-800">Visualización (Ciclo L/P)</h3>
                        <div class="toggle-switch-container">
                            <span class="toggle-switch-label">L/P</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="vizToggle" class="toggle-switch-input">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">R/N</span>
                        </div>
                        <div id="hexatonicCircle" class="circle-container w-full h-full">
                            <svg width="100%" height="100%" viewBox="0 0 300 300">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" />
                                    </marker>
                                </defs>
                                <!-- Nodos se añadirán dinámicamente -->
                            </svg>
                        </div>
                        <p id="circleDescription" class="text-sm text-gray-600 mt-2 text-center">
                            Ciclo Hexatónico. Las operaciones R, N y S pueden llevarte a un ciclo diferente.
                        </p>
                    </div>
                </div>

                <!-- Panel de Visualización del Tonnetz -->
                <div id="vizPaneTonnetz" class="viz-pane">
                    <div class="p-4 bg-white rounded-lg shadow-inner border border-blue-100 flex flex-col items-center justify-center h-[450px]">
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 text-center">Visualización del Tonnetz</h3>
                        <div id="tonnetzVisualization" class="w-full h-full border border-gray-200 rounded-lg bg-white flex justify-center items-center">
                            <!-- SVG Tonnetz se dibujará aquí dinámicamente -->
                        </div>
                        <p class="text-sm text-gray-600 mt-2 text-center">
                            Representación del Tonnetz. Las notas del acorde activo se resaltarán.
                        </p>
                    </div>
                </div>

            </div>
        </div>

    </div>

    <!-- Modal para información del autor -->
    <div id="authorModal" class="modal-overlay">
        <div class="modal-content text-center">
            <p class="text-gray-800 text-lg">Esta herramienta fue realizada por:</p>
            <p class="text-blue-600 text-2xl font-bold mt-2">Juan Miguel Ríos Redondo</p>
        </div>
    </div>
    
    <!-- Modal para el Glosario -->
    <div id="glossaryModal" class="modal-overlay">
        <div class="modal-content text-left">
            <h2 class="text-2xl font-bold text-blue-700 mb-4 text-center">Glosario de Términos</h2>
            
            <h3 class="text-lg font-semibold text-gray-800 mt-4">Involución</h3>
            <p class="text-gray-700">Una operación que es su propio inverso. Al aplicarla dos veces consecutivas, se vuelve al punto de partida.</p>
            
            <h3 class="text-lg font-semibold text-gray-800 mt-4">Conducción Idealizada (más eficiente)</h3>
            <p class="text-gray-700">Aquella conducción en la que los acordes se disponen de manera tal que cada voz se desplace la menor distancia posible, manteniendo fijas las notas en común.</p>
            
            <h3 class="text-lg font-semibold text-gray-800 mt-4">Ciclo Hexatónico</h3>
            <p class="text-gray-700">Un conjunto de seis tríadas (tres mayores y tres menores) generado por el encadenamiento alterno de las operaciones **L** y **P**.</p>
            
            <h3 class="text-lg font-semibold text-gray-800 mt-4">Región de Weitzmann</h3>
            <p class="text-gray-700">Un conjunto de seis tríadas (tres mayores y tres menores) generado por el encadenamiento alterno de las operaciones **R** y **N**. También puede generarse a partir de un acorde aumentado, moviendo cada una de sus notas un semitono hacia arriba (para crear las 3 menores) o hacia abajo (para crear las 3 mayores).</p>
            
            <h3 class="text-lg font-semibold text-gray-800 mt-4">Operación Compuesta</h3>
            <p class="text-gray-700">Dos o tres operaciones simples condensadas en una sola (ej. H = PLP, S = RNR).</p>

            <button id="closeGlossaryButton" class="btn btn-primary w-full mt-6">Cerrar</button>
        </div>
    </div>

    <script>
        // --- Banderas y Estado Global ---
        let hasModalBeenShown = false;
        let currentTriad;
        let previousTriad = null; // Para la visualización "fantasma"
        let history = [];
        let hexatonicCycleChords = []; // Acordes para la visualización del ciclo L/P
        let weitzmannCycleChords = []; // Acordes para la visualización del ciclo R/N
        let currentVisualizationMode = 'lp'; // 'lp' o 'rn'
        // NUEVO: Estado de Análisis
        let isInAnalysisMode = false;
        let currentAnalysis = null;
        let currentAnalysisStep = 0;

        // --- Audio Context ---
        let isToneStarted = false;
        const synth = new Tone.PolySynth().toDestination(); // CORRECCIÓN: No se debe pasar 'Tone.Synth' aquí
        let lastPlayedVoicing = []; // Guarda el último voicing reproducido (ej: ["C4", "E4", "G4"])

        async function startAudioContext() {
            if (isToneStarted) return;
            try {
                await Tone.start();
                isToneStarted = true;
                console.log("Audio context iniciado");
            } catch (e) {
                console.error("No se pudo iniciar el audio context", e);
            }
        }

        // --- Funciones de Audio y Voice Leading ---

        /**
         * NUEVA FUNCIÓN: Actualiza el 'lastPlayedVoicing' sin reproducir sonido.
         */
        function updateVoicing(midiNotes) {
            const toneNotes = midiNotes.map(midi => Tone.Frequency(midi, "midi").toNote());
            lastPlayedVoicing = toneNotes; // Guarda el nuevo voicing
        }

        /**
         * Reproduce un array de notas MIDI y lo guarda como el último voicing.
         */
        function playVoicing(midiNotes) {
            startAudioContext();
            updateVoicing(midiNotes); // <-- MODIFICADO: Llama a la nueva función para actualizar el estado
            // lastPlayedVoicing ya está actualizado
            synth.triggerAttackRelease(lastPlayedVoicing, "1s");
        }

        /**
         * Calcula el voicing más cercano para 'toTriad' partiendo de 'fromMidiNotes'.
         * Mantiene las notas comunes y mueve las restantes la distancia mínima.
         */
        function getClosestVoicing(fromMidiNotes, toTriad) {
            const fromPcs = fromMidiNotes.map(m => m % 12);
            const toPcs = toTriad.pitchClasses;
            
            const newVoicingMidi = [];
            const remainingToPcs = [...toPcs]; // PCs de destino que aún no han sido asignados
            const unmovedMidiNotes = []; // Notas MIDI de 'from' que se quedan
            const movedFromMidiNotes = []; // Notas MIDI de 'from' que deben moverse

            // 1. Encontrar y mantener notas comunes
            fromMidiNotes.forEach(midi => {
                const pc = midi % 12;
                const indexInTo = remainingToPcs.indexOf(pc);
                if (indexInTo !== -1) {
                    newVoicingMidi.push(midi); // Mantener la nota MIDI exacta
                    unmovedMidiNotes.push(midi);
                    remainingToPcs.splice(indexInTo, 1); // Este PC ya está asignado
                } else {
                    movedFromMidiNotes.push(midi); // Esta nota deberá moverse
                }
            });

            // 2. Asignar las notas que se mueven ('movedFromMidiNotes') a los PCs restantes ('remainingToPcs')
            movedFromMidiNotes.forEach(fromMidi => {
                let closestDist = Infinity;
                let bestNewMidi = 0;
                let bestPcIndex = -1;

                // Encontrar el PC de destino más cercano para esta nota
                remainingToPcs.forEach((toPc, index) => {
                    const baseOctave = Math.floor(fromMidi / 12);
                    const midiOpt1 = baseOctave * 12 + toPc; // Misma octava
                    const midiOpt2 = (baseOctave - 1) * 12 + toPc; // Octava abajo
                    const midiOpt3 = (baseOctave + 1) * 12 + toPc; // Octava arriba

                    const dist1 = Math.abs(midiOpt1 - fromMidi);
                    const dist2 = Math.abs(midiOpt2 - fromMidi);
                    const dist3 = Math.abs(midiOpt3 - fromMidi);

                    let currentClosestMidi;
                    let currentMinDist;

                    if (dist1 <= dist2 && dist1 <= dist3) {
                        currentClosestMidi = midiOpt1;
                        currentMinDist = dist1;
                    } else if (dist2 <= dist1 && dist2 <= dist3) {
                        currentClosestMidi = midiOpt2;
                        currentMinDist = dist2;
                    } else {
                        currentClosestMidi = midiOpt3;
                        currentMinDist = dist3;
                    }
                    
                    if (currentMinDist < closestDist) {
                        closestDist = currentMinDist;
                        bestNewMidi = currentClosestMidi;
                        bestPcIndex = index;
                    }
                });
                
                newVoicingMidi.push(bestNewMidi);
                remainingToPcs.splice(bestPcIndex, 1); // Este PC de destino ya se usó
            });

            return newVoicingMidi;
        }

        // --- Datos del Análisis Guiado ---
        const analysisData = {
            'liszt': {
                name: "Liszt - Consolación IV",
                imageUrl: "https://github.com/juanmiguel0927/TeoriaNeo-Riemanniana/raw/237988f08d9cfcc051ba15127077478eb15c7828/Liszt.png",
                steps: [
                    // Coordenadas (top, left, width, height) en %
                    { chord: 'B♭ menor', op: null, text: "Compás 20. Inicio del pasaje en Si♭ menor.", marker: { top: '25%', left: '8%', width: '15%', height: '60%' } },
                    { chord: 'D♭ Mayor', op: 'R', text: "Compás 21. Modelo (Paso 1): Se aplica la operación R (Relativo). B♭m → D♭M.", marker: { top: '25%', left: '23%', width: '15%', height: '60%' } },
                    { chord: 'D♭ menor', op: 'P', text: "Compás 21. Modelo (Paso 2): Se aplica la operación P (Paralelo). La cadena R-P está completa. D♭M → D♭m.", marker: { top: '25%', left: '38%', width: '15%', height: '60%' } },
                    { chord: 'E Mayor', op: 'R', text: "Compás 22. Progresión 1 (Paso 1): Se repite el patrón. Se aplica R. D♭m → EM.", marker: { top: '25%', left: '53%', width: '15%', height: '60%' } },
                    { chord: 'E menor', op: 'P', text: "Compás 22. Progresión 1 (Paso 2): Se aplica P. Se completa la cadena R-P. EM → Em.", marker: { top: '25%', left: '68%', width: '15%', height: '60%' } },
                    { chord: 'G menor', op: null, text: "Compás 23. Progresión 2 (Condensada): Se aplica una operación compuesta R-P (Em → GM → Gm) en un solo paso. Em → Gm.", marker: { top: '25%', left: '83%', width: '15%', height: '60%' } }
                ]
            },
            'schubert': {
                name: "Schubert - D.946 Nº2",
                imageUrl: "https://raw.githubusercontent.com/juanmiguel0927/TeoriaNeo-Riemanniana/237988f08d9cfcc051ba15127077478eb15c7828/Schubert.png",
                steps: [
                    // Coordenadas (top, left, width, height) en %
                    { chord: 'D menor', op: null, text: "Compás 46. Inicio del pasaje en Re menor.", marker: { top: '10%', left: '2%', width: '23%', height: '80%' } },
                    { chord: 'A Mayor', op: 'N', text: "Compás 48. Se aplica la operación N (Nebenverwandt). Dm → AM.", marker: { top: '10%', left: '26%', width: '23%', height: '80%' } },
                    { chord: 'F menor', op: 'H', text: "Compás 49. Se aplica H (Polo Hexatónico, PLP). No comparten notas. AM → Fm.", marker: { top: '10%', left: '50%', width: '24%', height: '80%' } },
                    { chord: 'C Mayor', op: 'N', text: "Compás 51. Se aplica la operación N (Nebenverwandt). Fm → CM.", marker: { top: '10%', left: '75%', width: '12%', height: '80%' } },
                    { chord: 'A♭ menor', op: 'H', text: "Compás 52. Se aplica H (Polo Hexatónico). CM → A♭m.", marker: { top: '10%', left: '88%', width: '10%', height: '80%' } }
                ]
            }
        };


        // --- Definiciones de Acordes y Notas ---
        
        // Mapeo de clase de altura (PC) a nombre de nota (usando sostenidos como primarios)
        const pitchClasses = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"];
        
        // Mapeo de nombre de nota a PC (maneja sostenidos y bemoles)
        const noteToPitchClass = {
            "C": 0, "C♯": 1, "D♭": 1, "D": 2, "D♯": 3, "E♭": 3, "E": 4, "F": 5, "F♯": 6, "G♭": 6, "G": 7, "G♯": 8, "A♭": 8, "A": 9, "A♯": 10, "B♭": 10, "B": 11
        };

        // Define una escritura canónica para cada PC (prefiere sostenidos por defecto)
        const canonicalSpelling = {
            0: "C", 1: "C♯", 2: "D", 3: "D♯", 4: "E", 5: "F",
            6: "F♯", 7: "G", 8: "G♯", 9: "A", 10: "A♯", 11: "B"
        };

        // Mapeo específico de PC para las notas del Tonnetz (incluyendo enarmonías)
        const tonnetzNoteToPc = {
            "C": 0, "C♯": 1, "D♭": 1, "D": 2, "D♯": 3, "E♭": 3, "E": 4, "E♯": 5, "F": 5, "F♯": 6, "G♭": 6, "G": 7, "G♯": 8, "A♭": 8, "A": 9, "A♯": 10, "B♭": 10, "B": 11, "B♯": 0, "C♭": 11, "F♭": 4, "Gx": 9, "Ax": 11
        };

        // Función para normalizar una clase de altura (mantenerla entre 0-11)
        function normalizePitch(pc) {
            return (pc % 12 + 12) % 12;
        }

        // Clase Triad
        class Triad {
            constructor(root, type) {
                this.root = root; // Nombre de la nota (ej. "C", "C#", "Db")
                this.type = type; // "major" o "minor"
                this.pitchClasses = this.calculatePitchClasses();
                this.name = `${root} ${type === 'major' ? 'Mayor' : 'menor'}`;
            }

            calculatePitchClasses() {
                const rootPc = noteToPitchClass[this.root];
                let thirdPc, fifthPc;

                if (this.type === "major") {
                    thirdPc = normalizePitch(rootPc + 4); // 3ra Mayor
                    fifthPc = normalizePitch(rootPc + 7); // 5ta Justa
                } else { // minor
                    thirdPc = normalizePitch(rootPc + 3); // 3ra menor
                    fifthPc = normalizePitch(rootPc + 7); // 5ta Justa
                }
                return [rootPc, thirdPc, fifthPc];
            }

            getNotes() {
                const notes = [];
                notes.push(this.root); // Raíz

                const thirdPc = this.pitchClasses[1];
                const fifthPc = this.pitchClasses[2];

                // Ayudante para obtener la enarmonía correcta
                const getNoteSpelling = (pc) => {
                    // Casos especiales
                    if (this.root === "C♯" && this.type === "major" && pc === 5) return "E♯";
                    if (this.root === "F♯" && this.type === "major" && pc === 0) return "B♯";
                    if (this.root === "G♯" && this.type === "major" && pc === 3) return "D♯"; // G# Mayor -> D#
                    if (this.root === "D♯" && this.type === "major" && pc === 8) return "G♯"; // D# Mayor -> G#
                    if (this.root === "A♯" && this.type === "major" && pc === 2) return "D♯"; // A# Mayor -> D#
                    // Casos de bemoles
                    if (this.root === "G♭" && this.type === "major" && pc === 10) return "B♭"; // G♭ Mayor -> B♭
                    if (this.root === "D♭" && this.type === "major" && pc === 5) return "F"; // D♭ Mayor -> F
                    if (this.root === "A♭" && this.type === "major" && pc === 0) return "C"; // A♭ Mayor -> C
                    if (this.root === "E♭" && this.type === "major" && pc === 7) return "G"; // E♭ Mayor -> G
                    if (this.root === "B♭" && this.type === "major" && pc === 2) return "D"; // B♭ Mayor -> D

                    const preferFlats = ["D♭", "E♭", "G♭", "A♭", "B♭"].includes(this.root) || 
                                        (this.root === "F") || 
                                        (this.root === "C" && this.type === "minor") || 
                                        (this.root === "G" && this.type === "minor") ||
                                        (this.root === "D" && this.type === "minor") || // Dm -> F, A
                                        (this.root === "A" && this.type === "minor"); // Am -> C, E

                    if (pc === 1 && preferFlats) return "D♭";
                    if (pc === 3 && preferFlats) return "E♭";
                    if (pc === 6 && preferFlats) return "G♭";
                    if (pc === 8 && preferFlats) return "A♭";
                    if (pc === 10 && preferFlats) return "B♭";

                    return canonicalSpelling[pc];
                };

                notes.push(getNoteSpelling(thirdPc)); // Tercera
                notes.push(getNoteSpelling(fifthPc)); // Quinta

                return notes;
            }

            // Comprueba si dos tríadas son la misma (misma raíz y tipo)
            isEqual(otherTriad) {
                return this.root === otherTriad.root && this.type === otherTriad.type;
            }

            // Comprueba si dos tríadas tienen las mismas PC (enarmónicamente equivalentes)
            hasSamePitchClasses(otherTriad) {
                if (!otherTriad) return false; // Protección contra nulos
                const sortedThis = [...this.pitchClasses].sort();
                const sortedOther = [...otherTriad.pitchClasses].sort();
                return sortedThis.every((pc, i) => pc === sortedOther[i]);
            }
        }

        // Definir todos los 17 nombres de raíces posibles para crear todas las 24 tríadas
        const allPossibleRootNames = ["C", "C♯", "D♭", "D", "D♯", "E♭", "E", "F", "F♯", "G♭", "G", "G♯", "A♭", "A", "A♯", "B♭", "B"];
        const allTriads = [];
        allPossibleRootNames.forEach(root => {
            if (noteToPitchClass[root] !== undefined) {
                allTriads.push(new Triad(root, "major"));
                allTriads.push(new Triad(root, "minor")); 
            }
        });

        // Ayudante para obtener un objeto Triad por nombre
        function getTriadByName(name) {
            // Normalizar nombres de entrada (ej. "C Mayor", "C mayor", "c mayor")
            let normalizedName = name.trim();
            if (normalizedName.length < 1) return null; // CORRECCIÓN: Cambiado de < 2 a < 1 para aceptar "C", "F", etc.

            // NUEVO: Normalizar sostenidos y bemoles de texto
            normalizedName = normalizedName.replace(/b/g, '♭').replace(/#/g, '♯');

            // Manejar "m" o "menor"
            let type = "major";
            if (normalizedName.toLowerCase().endsWith("m") || normalizedName.toLowerCase().endsWith("menor")) {
                type = "minor";
                normalizedName = normalizedName.replace(/menor/i, '').replace(/m/i, '').trim();
            } else {
                normalizedName = normalizedName.replace(/Mayor/i, '').replace(/M/i, '').trim();
            }

            // Capitalizar la raíz (ej. "c" -> "C", "c#" -> "C#", "db" -> "Db")
            let rootName = normalizedName.charAt(0).toUpperCase() + normalizedName.slice(1);
            // Manejar bemoles
            if (rootName.length > 1 && rootName.charAt(1) === 'b') {
                rootName = rootName.charAt(0) + '♭';
            }
            // Manejar sostenidos
             if (rootName.length > 1 && rootName.charAt(1) === '♯') {
                rootName = rootName.charAt(0) + '♯';
            }
            
            const finalName = `${rootName} ${type === 'major' ? 'Mayor' : 'menor'}`;
            return allTriads.find(t => t.name === finalName);
        }

        // --- Operaciones Neo-Riemannianas ---
        
        // Ayudante para encontrar una tríada por sus PC (para operaciones)
        function findTriadByPitchClasses(pcs, type) {
            const sortedPcs = [...pcs].sort();
            for (const triad of allTriads) {
                const sortedTriadPcs = [...triad.pitchClasses].sort();
                if (triad.type === type && sortedPcs.every((pc, i) => pc === sortedTriadPcs[i])) {
                    return triad;
                }
            }
            return null; // No encontrado
        }

        function opL(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // DoM (C-E-G) [0,4,7] -> Mim (E-G-B) [4,7,11]
                newPcs = [normalizePitch(r - 1), t, f]; // Mueve C(0) -> B(11)
                newType = "minor";
            } else { // Mim (E-G-B) [4,7,11] -> DoM (C-E-G) [0,4,7]
                newPcs = [r, t, normalizePitch(f + 1)]; // Mueve B(11) -> C(0)
                newType = "major";
            }
            // MODIFICACIÓN: Encontrar la *mejor* tríada enarmónica
            const resultTriad = findTriadByPitchClasses(newPcs, newType);
            if (triad.type === "major") { // DoM -> Mim (Esperamos raíz E)
                const expectedRoot = canonicalSpelling[t];
                return allTriads.find(t => t.root === expectedRoot && t.type === newType) || resultTriad;
            }
            if (triad.type === "minor") { // Mim -> DoM (Esperamos raíz C)
                const expectedRoot = canonicalSpelling[normalizePitch(f+1)];
                return allTriads.find(t => t.root === expectedRoot && t.type === newType) || resultTriad;
            }
            return resultTriad;
        }

        function opP(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C(0), E(4), G(7) -> C(0), Eb(3), G(7)
                newPcs = [r, normalizePitch(t - 1), f];
                newType = "minor";
            } else { // Cm(0), Eb(3), G(7) -> C(0), E(4), G(7)
                newPcs = [r, normalizePitch(t + 1), f];
                newType = "major";
            }
            // La raíz no cambia, así que podemos buscarla por nombre
            const newRootName = triad.root;
            return allTriads.find(t => t.root === newRootName && t.type === newType) || findTriadByPitchClasses(newPcs, newType);
        }

        function opR(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C(0), E(4), G(7) -> A(9), C(0), E(4) -> La menor
                newPcs = [normalizePitch(r - 3), r, t];
                newType = "minor";
            } else { // Am(9), C(0), E(4) -> C(0), E(4), G(7) -> Do Mayor
                newPcs = [t, f, normalizePitch(f + 3)];
                newType = "major";
            }
             // La raíz cambia, encontrar la mejor escritura
            const resultTriad = findTriadByPitchClasses(newPcs, newType);
            if (triad.type === "major") { // DoM -> Lam (Esperamos raíz A)
                const expectedRoot = canonicalSpelling[normalizePitch(r-3)];
                return allTriads.find(t => t.root === expectedRoot && t.type === newType) || resultTriad;
            }
            if (triad.type === "minor") { // Lam -> DoM (Esperamos raíz C)
                const expectedRoot = canonicalSpelling[t];
                return allTriads.find(t => t.root === expectedRoot && t.type === newType) || resultTriad;
            }
            return resultTriad;
        }

        function opN(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C(0), E(4), G(7) -> F(5), Ab(8), C(0) -> Fa menor
                newPcs = [normalizePitch(r + 5), normalizePitch(t + 4), r];
                newType = "minor";
            } else { // Fm(5), Ab(8), C(0) -> C(0), E(4), G(7) -> Do Mayor
                newPcs = [f, normalizePitch(r - 1), normalizePitch(t - 1)]; 
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opH(triad) { // PLP
            let result = opP(triad);
            result = opL(result);
            result = opP(result);
            return result;
        }

        function opS(triad) { // RNR
            let result = opR(triad);
            if (!result) { console.error("S falló en R1", triad); return null; }
            result = opN(result);
            if (!result) { console.error("S falló en N", triad); return null; }
            result = opR(result);
            if (!result) { console.error("S falló en R2", triad); return null; }
            return result;
        }

        // NUEVA FUNCIÓN: Encontrar la mejor operación entre dos tríadas
        function findBestOperation(triadA, triadB) {
            if (opP(triadA).hasSamePitchClasses(triadB)) return 'P';
            if (opL(triadA).hasSamePitchClasses(triadB)) return 'L';
            if (opR(triadA).hasSamePitchClasses(triadB)) return 'R';
            if (opN(triadA).hasSamePitchClasses(triadB)) return 'N';
            if (opS(triadA).hasSamePitchClasses(triadB)) return 'S';
            if (opH(triadA).hasSamePitchClasses(triadB)) return 'H';
            return '??'; // No se encontró una operación simple
        }

        // --- Definiciones de Ciclos y Regiones ---

        // Ciclos Hexatónicos (L/P)
        const hexatonicCycles = [
            { name: "Ciclo I (C/E/G♯)", members: [] },
            { name: "Ciclo II (C♯/F/A)", members: [] },
            { name: "Ciclo III (D/F♯/B♭)", members: [] },
            { name: "Ciclo IV (D♯/G/B)", members: [] }
        ];

        function generateAndPopulateHexatonicCycle(startMajorTriad, cycleIndex) {
            const cycle = [];
            let current = startMajorTriad;
            for (let i = 0; i < 6; i++) {
                if (!current) {
                    console.error(`Fallo en Ciclo L/P ${cycleIndex}, paso ${i}. Acorde inicial: ${startMajorTriad.name}`);
                    return;
                }
                cycle.push(current);
                if (i % 2 === 0) { current = opL(current); } // L
                else { current = opP(current); } // P
            }
            hexatonicCycles[cycleIndex].members = cycle.filter(Boolean);
        }

        generateAndPopulateHexatonicCycle(getTriadByName("C Mayor"), 0);
        generateAndPopulateHexatonicCycle(getTriadByName("C♯ Mayor"), 1);
        generateAndPopulateHexatonicCycle(getTriadByName("D Mayor"), 2);
        generateAndPopulateHexatonicCycle(getTriadByName("D♯ Mayor"), 3);

        // Regiones de Weitzmann (R/N)
        const weitzmannCycles = [ // Usamos "Cycles" para consistencia en la función de dibujo
            { name: "Región I (C/E/G♯)", members: [] },
            { name: "Región II (C♯/F/A)", members: [] },
            { name: "Región III (D/F♯/B♭)", members: [] },
            { name: "Región IV (D♯/G/B)", members: [] }
        ];
        
        function generateAndPopulateWeitzmannCycle(startMajorTriad, cycleIndex) {
            const cycle = [];
            let current = startMajorTriad;
            for (let i = 0; i < 6; i++) {
                if (!current) { // Prevención de errores
                    console.error(`Fallo en Ciclo R/N ${cycleIndex}, paso ${i}. Acorde inicial: ${startMajorTriad.name}`);
                    return; 
                }
                cycle.push(current);
                if (i % 2 === 0) { current = opR(current); } // R
                else { current = opN(current); } // N
            }
            weitzmannCycles[cycleIndex].members = cycle.filter(Boolean);
        }

        generateAndPopulateWeitzmannCycle(getTriadByName("C Mayor"), 0);
        generateAndPopulateWeitzmannCycle(getTriadByName("C♯ Mayor"), 1);
        generateAndPopulateWeitzmannCycle(getTriadByName("D Mayor"), 2);
        generateAndPopulateWeitzmannCycle(getTriadByName("D♯ Mayor"), 3);


        // Regiones (para la sección de "Relación entre Conjuntos")
        const weitzmannRegions = [
            { name: "Región de C-E-G♯", members: weitzmannCycles[0].members },
            { name: "Región de C♯-F-A", members: weitzmannCycles[1].members },
            { name: "Región de D-F♯-B♭", members: weitzmannCycles[2].members },
            { name: "Región de D♯-G-B", members: weitzmannCycles[3].members }
        ];


        // --- Elementos del DOM ---
        const startChordSelect = document.getElementById("startChord");
        const resetButton = document.getElementById("resetButton");
        const glossaryButton = document.getElementById("glossaryButton");
        const closeGlossaryButton = document.getElementById("closeGlossaryButton");
        const glossaryModal = document.getElementById("glossaryModal");
        const authorModal = document.getElementById('authorModal');
        const playChordButton = document.getElementById("playChordButton");
        // Controles de exploración libre
        const startChordContainer = document.getElementById("startChordContainer");
        // ... (operationsBox ya está definida)

        // NUEVO: Controles de Análisis
        const analysisSelect = document.getElementById("analysisSelect");
        const analysisControls = document.getElementById("analysisControls");
        const analysisTitle = document.getElementById("analysisTitle");
        const analysisScoreContainer = document.getElementById("analysisScoreContainer"); // <-- NUEVO
        const analysisScoreImage = document.getElementById("analysisScoreImage");
        const analysisScoreMarker = document.getElementById("analysisScoreMarker"); // <-- NUEVO
        const analysisExplanation = document.getElementById("analysisExplanation");
        const prevStepBtn = document.getElementById("prevStepBtn");
        const nextStepBtn = document.getElementById("nextStepBtn");
        const exitAnalysisBtn = document.getElementById("exitAnalysisBtn");
        // NUEVO: Elementos de Análisis Libre
        const freeAnalysisContainer = document.getElementById("freeAnalysisContainer");
        const freeAnalysisInput = document.getElementById("freeAnalysisInput");
        const freeAnalysisButton = document.getElementById("freeAnalysisButton");
        const freeAnalysisError = document.getElementById("freeAnalysisError");


        const currentChordName = document.getElementById("currentChordName");
        const currentChordNotes = document.getElementById("currentChordNotes");
        const operationExplanation = document.getElementById("operationExplanation");
        const historyLog = document.getElementById("historyLog");
        const operationsBox = document.getElementById('operationsBox');
        const operationButtons = document.querySelectorAll('#operationsBox button');
        const mainChordDisplay = document.querySelector('.chord-display'); // AÑADIDO
        // Guardar referencias a botones específicos
        const opBtnL = document.getElementById('opL');
        const opBtnP = document.getElementById('opP');
        const opBtnR = document.getElementById('opR');
        const opBtnN = document.getElementById('opN');
        const opBtnH = document.getElementById('opH');
        const opBtnS = document.getElementById('opS');

        // Pestañas
        const vizTabs = document.querySelectorAll('.viz-tab-btn');
        const vizPanes = document.querySelectorAll('.viz-pane');

        // Visualización del Círculo
        const vizToggle = document.getElementById("vizToggle");
        const circleTitle = document.getElementById("circleTitle");
        const circleDescription = document.getElementById("circleDescription");
        const hexatonicCircleSvg = document.querySelector("#hexatonicCircle svg");

        // Visualización del Tonnetz
        const tonnetzVisualizerDiv = document.getElementById('tonnetzVisualization');
        const tonnetzSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        tonnetzSvg.setAttribute("width", "100%");
        tonnetzSvg.setAttribute("height", "100%");
        tonnetzVisualizerDiv.appendChild(tonnetzSvg);
        let coordToNodeMap = new Map(); // Mapa de coordenadas del Tonnetz

        // Relaciones de Conjuntos
        const setRelationshipsDiv = document.getElementById("setRelationships");
        const currentHexatonicCycleSpan = document.getElementById("currentHexatonicCycle");
        const hexatonicCycleMembersDiv = document.getElementById("hexatonicCycleMembers");
        const currentWeitzmannRegionSpan = document.getElementById("currentWeitzmannRegion");
        const weitzmannRegionMembersDiv = document.getElementById("weitzmannRegionMembers");
        const sharedChordsDiv = document.getElementById("sharedChords");
        

        // --- Explicaciones de Operaciones ---
        const explanations = {
            "L": "<strong>L (Leittonechel / Intercambio de Tono Principal)</strong>: Transforma una tríada mayor en menor (y viceversa).<br>• <strong>Mayor → menor</strong>: Conserva la 3ª menor (Mi-Sol en DoM) y mueve la fundamental 1 semitono hacia abajo (Do → Si). Ej: <strong>DoM (C-E-G) → Mim (B-E-G)</strong>.<br>• <strong>menor → Mayor</strong>: Conserva la 3ª menor (Mi-Sol en Mim) y mueve la quinta 1 semitono hacia arriba (Si → Do). Ej: <strong>Mim (E-G-B) → DoM (E-G-C)</strong>.",
            "P": "<strong>P (Parallel / Paralelo)</strong>: Transforma una tríada en su paralela (mismo nombre, modo opuesto). Conserva la tónica y la quinta, y mueve la tercera 1 semitono.<br>• <strong>Mayor → menor</strong>: Baja la tercera (Mi → Mi♭). Ej: <strong>DoM (C-E-G) → Dom (C-E♭-G)</strong>.<br>• <strong>menor → Mayor</strong>: Sube la tercera (Mi♭ → Mi). Ej: <strong>Dom (C-E♭-G) → DoM (C-E-G)</strong>.",
            "R": "<strong>R (Relative / Relativo)</strong>: Transforma una tríada en su relativa (comparten dos notas y la armadura).<br>• <strong>Mayor → menor</strong>: Conserva la 3ª mayor (Do-Mi en DoM) y mueve la quinta 1 tono hacia arriba (Sol → La). Ej: <strong>DoM (C-E-G) → Lam (C-E-A)</strong>.<br>• <strong>menor → Mayor</strong>: Conserva la 3ª mayor (Do-Mi en Lam) y mueve la fundamental 1 tono hacia abajo (La → Sol). Ej: <strong>Lam (A-C-E) → DoM (G-C-E)</strong>.",
            "N": "<strong>N (Nebenverwandt / Próximo Relacionado)</strong>: Operación que invierte el acorde. Mueve dos voces.<br>• <strong>Mayor → menor</strong>: Ej: <strong>DoM (C-E-G) → Fam (F-A♭-C)</strong>.<br>• <strong>menor → Mayor</strong>: Ej: <strong>Fam (F-A♭-C) → DoM (C-E-G)</strong>.",
            "H": "<strong>H (Hexatonic Pole / Polo Hexatónico)</strong>: Operación compuesta (<strong>PLP</strong> o <strong>LPL</strong>). Conecta dos tríadas opuestas dentro del mismo ciclo hexatónico (no comparten ninguna nota). Ej: <strong>DoM (C-E-G) → Sol♯m (G♯-B-D♯)</strong>.",
            "S": "<strong>S (Slide / Deslizamiento)</strong>: Operación compuesta (<strong>RNR</strong> o <strong>NRN</strong>). Conecta dos tríadas de modo opuesto que comparten la tercera. Ej: <strong>DoM (C-E-G) → Do♯m (C♯-E-G♯)</strong>."
        };

        function displayOperationExplanation(opCode) {
            operationExplanation.innerHTML = explanations[opCode] || "Selecciona una operación para ver su descripción.";
        }
        
        // --- Lógica de Modales ---
        function showAuthorModal() {
            if (!hasModalBeenShown) {
                authorModal.classList.add('show');
                setTimeout(() => {
                    authorModal.classList.remove('show');
                }, 4000); // Ocultar después de 4 segundos
                hasModalBeenShown = true;
            }
        }
        
        glossaryButton.addEventListener('click', () => glossaryModal.classList.add('show'));
        closeGlossaryButton.addEventListener('click', () => glossaryModal.classList.remove('show'));

        // --- Lógica de Pestañas de Visualización ---
        vizTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Desactivar todas las pestañas y paneles
                vizTabs.forEach(t => t.classList.remove('active'));
                vizPanes.forEach(p => p.classList.remove('active'));

                // Activar la pestaña y panel seleccionados
                tab.classList.add('active');
                const vizName = tab.dataset.viz;
                document.getElementById(`vizPane${vizName.charAt(0).toUpperCase() + vizName.slice(1)}`).classList.add('active');
            });
        });

        // --- Visualización del Tonnetz (Datos y Dibujo) ---
        
        // Nodos del Tonnetz con coordenadas
        const tonnetzNodesData = [
            { note: "D♯", pc: tonnetzNoteToPc["D♯"], x: 0, y: 0 }, { note: "A♯", pc: tonnetzNoteToPc["A♯"], x: 80, y: 0 }, { note: "E♯", pc: tonnetzNoteToPc["E♯"], x: 160, y: 0 }, { note: "B♯", pc: tonnetzNoteToPc["B♯"], x: 240, y: 0 }, { note: "Gx", pc: tonnetzNoteToPc["Gx"], x: 320, y: 0 },
            { note: "B", pc: tonnetzNoteToPc["B"], x: -40, y: 45 }, { note: "F♯", pc: tonnetzNoteToPc["F♯"], x: 40, y: 45 }, { note: "C♯", pc: tonnetzNoteToPc["C♯"], x: 120, y: 45 }, { note: "G♯", pc: tonnetzNoteToPc["G♯"], x: 200, y: 45 }, { note: "D♯", pc: tonnetzNoteToPc["D♯"], x: 280, y: 45 }, { note: "A♯", pc: tonnetzNoteToPc["A♯"], x: 360, y: 45 },
            { note: "D", pc: tonnetzNoteToPc["D"], x: 0, y: 90 }, { note: "A", pc: tonnetzNoteToPc["A"], x: 80, y: 90 }, { note: "E", pc: tonnetzNoteToPc["E"], x: 160, y: 90 }, { note: "B", pc: tonnetzNoteToPc["B"], x: 240, y: 90 }, { note: "F♯", pc: tonnetzNoteToPc["F♯"], x: 320, y: 90 }, { note: "C♯", pc: tonnetzNoteToPc["C♯"], x: 400, y: 90 },
            { note: "B♭", pc: tonnetzNoteToPc["B♭"], x: -40, y: 135 }, { note: "F", pc: tonnetzNoteToPc["F"], x: 40, y: 135 }, { note: "C", pc: tonnetzNoteToPc["C"], x: 120, y: 135 }, { note: "G", pc: tonnetzNoteToPc["G"], x: 200, y: 135 }, { note: "D", pc: tonnetzNoteToPc["D"], x: 280, y: 135 }, { note: "A", pc: tonnetzNoteToPc["A"], x: 360, y: 135 },
            { note: "D♭", pc: tonnetzNoteToPc["D♭"], x: 0, y: 180 }, { note: "A♭", pc: tonnetzNoteToPc["A♭"], x: 80, y: 180 }, { note: "E♭", pc: tonnetzNoteToPc["E♭"], x: 160, y: 180 }, { note: "B♭", pc: tonnetzNoteToPc["B♭"], x: 240, y: 180 }, { note: "F", pc: tonnetzNoteToPc["F"], x: 320, y: 180 }, { note: "C", pc: tonnetzNoteToPc["C"], x: 400, y: 180 },
            { note: "Ax", pc: tonnetzNoteToPc["Ax"], x: -40, y: 225 }, { note: "F♭", pc: tonnetzNoteToPc["F♭"], x: 40, y: 225 }, { note: "C♭", pc: tonnetzNoteToPc["C♭"], x: 120, y: 225 }, { note: "G♭", pc: tonnetzNoteToPc["G♭"], x: 200, y: 225 }, { note: "D♭", pc: tonnetzNoteToPc["D♭"], x: 280, y: 225 }, { note: "A♭", pc: tonnetzNoteToPc["A♭"], x: 360, y: 225 },
        ];
        
        // Ayudante para dibujar una línea en SVG
        function drawLine(svg, p1, p2, color, strokeWidth = "1") {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", p1.x); line.setAttribute("y1", p1.y);
            line.setAttribute("x2", p2.x); line.setAttribute("y2", p2.y);
            line.setAttribute("stroke", color); line.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(line);
        }

        function drawFullTonnetz() {
            tonnetzSvg.innerHTML = `
                <defs>
                    <marker id="arrowhead-tonnetz" markerWidth="5" markerHeight="3.5" refX="0" refY="1.75" orient="auto" fill="#3b82f6">
                        <polygon points="0 0, 5 1.75, 0 3.5" />
                    </marker>
                </defs>
            `; // Limpiar y añadir DEFS para la flecha
            coordToNodeMap = new Map();
            tonnetzNodesData.forEach(node => coordToNodeMap.set(`${node.x},${node.y}`, node));

            const P5_HORIZONTAL_SPACING = 80;
            const THIRD_VERTICAL_SPACING = 45;
            const THIRD_HORIZONTAL_OFFSET = P5_HORIZONTAL_SPACING / 2;

            // Dibujar conexiones
            tonnetzNodesData.forEach(node => {
                if (coordToNodeMap.has(`${node.x + P5_HORIZONTAL_SPACING},${node.y}`)) {
                    drawLine(tonnetzSvg, node, coordToNodeMap.get(`${node.x + P5_HORIZONTAL_SPACING},${node.y}`), "#cbd5e1");
                }
                if (coordToNodeMap.has(`${node.x + THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`)) {
                    drawLine(tonnetzSvg, node, coordToNodeMap.get(`${node.x + THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`), "#cbd5e1");
                }
                if (coordToNodeMap.has(`${node.x - THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`)) {
                    drawLine(tonnetzSvg, node, coordToNodeMap.get(`${node.x - THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`), "#cbd5e1");
                }
            });

            // Dibujar nodos
            tonnetzNodesData.forEach(pos => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", pos.x); circle.setAttribute("cy", pos.y);
                circle.setAttribute("r", 15); circle.setAttribute("fill", "#e2e8f0");
                circle.setAttribute("stroke", "#94a3b8"); circle.setAttribute("stroke-width", "1");
                circle.classList.add("tonnetz-node-circle");
                circle.dataset.note = pos.note;

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", pos.x); text.setAttribute("y", pos.y + 5);
                text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "10");
                text.setAttribute("fill", "#475569"); text.textContent = pos.note;
                text.classList.add("tonnetz-node-text");
                text.dataset.note = pos.note;

                tonnetzSvg.appendChild(circle);
                tonnetzSvg.appendChild(text);
            });

            // Actualizar viewBox
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            tonnetzNodesData.forEach(node => {
                minX = Math.min(minX, node.x - 15); minY = Math.min(minY, node.y - 15);
                maxX = Math.max(maxX, node.x + 15); maxY = Math.max(maxY, node.y + 15);
            });
            const padding = 20;
            const finalWidth = maxX - minX + 2 * padding;
            const finalHeight = maxY - minY + 2 * padding;
            tonnetzSvg.setAttribute("viewBox", `${minX - padding} ${minY - padding} ${finalWidth} ${finalHeight}`);
        }

        // Resaltar la tríada en el Tonnetz
        function highlightTonnetzTriad(activeTriad, prevTriad = null) {
            // Limpiar resaltados anteriores
            tonnetzSvg.querySelectorAll('.active').forEach(node => node.classList.remove('active'));
            tonnetzSvg.querySelectorAll('.previous-active').forEach(node => node.classList.remove('previous-active'));
            tonnetzSvg.querySelectorAll('.tonnetz-triad-fill').forEach(fill => fill.remove());
            tonnetzSvg.querySelectorAll('.tonnetz-transformation-path').forEach(path => path.remove()); // Limpiar flecha
            
            // Función interna para resaltar un acorde
            // AHORA DEVUELVE EL CENTRO DEL TRIÁNGULO
            const highlight = (triad, cssClass) => {
                if (!triad) return null; // Devuelve null si no hay tríada
                const triadPcs = triad.pitchClasses;
                triadPcs.forEach(pc => {
                    const matchingTonnetzNodes = tonnetzNodesData.filter(node => node.pc === pc);
                    matchingTonnetzNodes.forEach(tonnetzNode => {
                        tonnetzSvg.querySelectorAll(`.tonnetz-node-circle[data-note="${tonnetzNode.note}"]`).forEach(node => node.classList.add(cssClass));
                        tonnetzSvg.querySelectorAll(`.tonnetz-node-text[data-note="${tonnetzNode.note}"]`).forEach(node => node.classList.add(cssClass));
                    });
                });
                
                // Dibujar el triángulo
                const [rootPc, thirdPc, fifthPc] = triad.pitchClasses;
                const possibleRootNodes = tonnetzNodesData.filter(node => node.pc === rootPc);
                
                for (const pRootNode of possibleRootNodes) {
                    let pThirdNode = null, pFifthNode = null;
                    const P5_HORIZONTAL_SPACING = 80;
                    const THIRD_VERTICAL_SPACING = 45;
                    const THIRD_HORIZONTAL_OFFSET = P5_HORIZONTAL_SPACING / 2;
                    
                    if (triad.type === "major") {
                        pThirdNode = coordToNodeMap.get(`${pRootNode.x + THIRD_HORIZONTAL_OFFSET},${pRootNode.y - THIRD_VERTICAL_SPACING}`);
                        pFifthNode = coordToNodeMap.get(`${pRootNode.x + P5_HORIZONTAL_SPACING},${pRootNode.y}`);
                    } else { // minor
                        pThirdNode = coordToNodeMap.get(`${pRootNode.x - THIRD_HORIZONTAL_OFFSET},${pRootNode.y - THIRD_VERTICAL_SPACING}`);
                        pFifthNode = coordToNodeMap.get(`${pRootNode.x + P5_HORIZONTAL_SPACING},${pRootNode.y}`);
                    }

                    if (pThirdNode && pFifthNode && pThirdNode.pc === thirdPc && pFifthNode.pc === fifthPc) {
                        const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                        polygon.setAttribute("points", `${pRootNode.x},${pRootNode.y} ${pThirdNode.x},${pThirdNode.y} ${pFifthNode.x},${pFifthNode.y}`);
                        polygon.classList.add("tonnetz-triad-fill", cssClass);
                        tonnetzSvg.prepend(polygon);
                        
                        // Calcular y devolver el centro del triángulo
                        const centerX = (pRootNode.x + pThirdNode.x + pFifthNode.x) / 3;
                        const centerY = (pRootNode.y + pThirdNode.y + pFifthNode.y) / 3;
                        return { x: centerX, y: centerY };
                    }
                }
                return null; // No se encontró el triángulo
            };
            
            // Resaltar el acorde anterior (fantasma) y obtener su centro
            const prevCenter = highlight(prevTriad, 'previous-active');
            // Resaltar el acorde actual (activo) y obtener su centro
            const activeCenter = highlight(activeTriad, 'active');

            // Dibujar la flecha de transformación si tenemos ambos centros
            if (prevCenter && activeCenter && (prevCenter.x !== activeCenter.x || prevCenter.y !== activeCenter.y)) {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", `M ${prevCenter.x} ${prevCenter.y} L ${activeCenter.x} ${activeCenter.y}`);
                path.classList.add("tonnetz-transformation-path");
                tonnetzSvg.appendChild(path);
            }
        }


        // --- Lógica de la Aplicación ---
        
        // Poblar selector de acordes
        function populateStartChordSelect() {
            const orderedRoots = ["C", "D♭", "D", "E♭", "E", "F", "F♯", "G", "A♭", "A", "B♭", "B"];
            const addedNames = new Set();
            
            orderedRoots.forEach(rootName => {
                ["major", "minor"].forEach(type => {
                    const triad = allTriads.find(t => t.root === rootName && t.type === type);
                    if (triad && !addedNames.has(triad.name)) {
                        const option = document.createElement("option");
                        option.value = triad.name;
                        option.textContent = triad.name;
                        startChordSelect.appendChild(option);
                        addedNames.add(triad.name);
                    }
                });
            });
            startChordSelect.value = "C Mayor";
        }

        /**
         * NUEVA FUNCIÓN: Establece el acorde de inicio y reinicia la UI.
         * Separada de initializeApp para evitar que el modal se muestre en cada cambio.
         */
        function setStartChord(chordName) {
            try {
                exitAnalysis(); // Asegurarse de que el modo análisis esté desactivado
                
                currentTriad = allTriads.find(t => t.name === chordName);
                previousTriad = null;
                if (!currentTriad) {
                    currentTriad = getTriadByName("C Mayor");
                }
                history = [];
                currentVisualizationMode = 'lp'; // Asegurarse de que el modo inicial es 'lp'
                vizToggle.checked = false; // Asegurarse de que el toggle esté en la posición 'lp'

                // Inicializar el lastPlayedVoicing
                const rootNotes = currentTriad.getNotes();
                const toneNotes = rootNotes.map(n => `${n.replace('♯', '#').replace('♭', 'b')}4`);
                lastPlayedVoicing = toneNotes; // Inicializa en la 4ª octava
                const midiNotes = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                updateVoicing(midiNotes); // Preparar el voicing sin reproducir

                updateUI();
                displayOperationExplanation('');
                removeActiveOperationHighlight();
                removeOperationsBoxHighlight();
                updateOperationButtonHighlights();

            } catch (error) {
                console.error("Error al establecer el acorde de inicio:", error);
            }
        }

        // Inicializar o reiniciar la app
        function initializeApp() {
            // Ahora solo llama a setStartChord y muestra el modal
            setStartChord(startChordSelect.value);
            showAuthorModal();
        }

        // Actualizar toda la UI
        function updateUI() {
            if (!currentTriad) return;

            currentChordName.textContent = currentTriad.name;
            const notes = currentTriad.getNotes();
            currentChordNotes.innerHTML = `Raíz: <span class="font-bold">${notes[0]}</span>, Tercera: <span class="font-bold">${notes[1]}</span>, Quinta: <span class="font-bold">${notes[2]}</span>`;
            
            updateHistoryLog();
            updateSetRelationshipsDisplay();
            
            // Actualizar las 2 visualizaciones
            updateCircleVisualization(currentTriad, previousTriad);
            highlightTonnetzTriad(currentTriad, previousTriad);
        }

        // Añadir entrada al historial
        function addHistoryEntry(operationName, oldTriad, newTriad) {
            const entry = {
                operation: operationName,
                from: oldTriad.name,
                to: newTriad.name,
                timestamp: new Date().toLocaleTimeString()
            };
            history.push(entry);
            historyLog.scrollTop = 0; // Ir al inicio (más reciente arriba)
        }

        // Renderizar el historial
        function updateHistoryLog() {
            historyLog.innerHTML = "";
            if (history.length === 0) {
                historyLog.innerHTML = "<p class='text-gray-500'>No hay transformaciones aún.</p>";
                return;
            }
            [...history].reverse().forEach(entry => { // Invertido para mostrar el más reciente arriba
                const div = document.createElement("div");
                div.className = "history-item";
                div.textContent = `${entry.timestamp}: ${entry.from} --(${entry.operation})--> ${entry.to}`;
                historyLog.prepend(div);
            });
        }

        // --- Funciones de Relaciones de Conjuntos ---
        function getHexatonicCycleForTriad(triad) {
            if (!triad) return null;
            for (const cycle of hexatonicCycles) {
                if (cycle.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return cycle;
                }
            }
            return null;
        }

        function getWeitzmannRegionForTriad(triad) {
            if (!triad) return null;
            // Compara usando el nombre del ciclo, que ahora coincide
            const hexCycle = getHexatonicCycleForTriad(triad);
            if (!hexCycle) return null;
            
            // Asume que los índices coinciden (Ciclo I -> Región I)
            const cycleIndex = hexatonicCycles.findIndex(c => c.name === hexCycle.name);
            if (cycleIndex !== -1 && weitzmannRegions[cycleIndex]) {
                return weitzmannRegions[cycleIndex];
            }
            return null;
        }

        function updateSetRelationshipsDisplay() {
            const hexCycle = getHexatonicCycleForTriad(currentTriad);
            const weitzRegion = getWeitzmannRegionForTriad(currentTriad);

            const createChordSpan = (triad, color) => {
                if (!triad) return ""; // Añadir chequeo por si la tríada es nula
                
                // --- MODIFICADO ---
                // Determinar el nombre a mostrar (para enarmonía)
                let displayName = triad.name;
                if (currentTriad && triad.hasSamePitchClasses(currentTriad) && triad.type === currentTriad.type) {
                    displayName = currentTriad.name; // Usar ortografía activa
                } else if (previousTriad && triad.hasSamePitchClasses(previousTriad) && triad.type === previousTriad.type) {
                    displayName = previousTriad.name; // Usar ortografía previa
                }
                
                return `<span class="bg-${color}-100 text-${color}-800 px-2 py-1 rounded-md cursor-pointer hover:bg-${color}-200" data-chord-name="${triad.name}">${displayName}</span>`;
                // --- FIN DE MODIFICACIÓN ---
            };

            if (hexCycle) {
                currentHexatonicCycleSpan.textContent = hexCycle.name;
                hexatonicCycleMembersDiv.innerHTML = hexCycle.members.map(t => createChordSpan(t, 'blue')).join('');
            } else {
                currentHexatonicCycleSpan.textContent = "No encontrado";
                hexatonicCycleMembersDiv.innerHTML = "";
            }

            if (weitzRegion) {
                currentWeitzmannRegionSpan.textContent = weitzRegion.name;
                weitzmannRegionMembersDiv.innerHTML = weitzRegion.members.map(t => createChordSpan(t, 'green')).join('');
            } else {
                currentWeitzmannRegionSpan.textContent = "No encontrado";
                weitzmannRegionMembersDiv.innerHTML = "";
            }

            if (hexCycle && weitzRegion) {
                const shared = hexCycle.members.filter(hexMember =>
                    weitzRegion.members.some(weitzMember => weitzMember.hasSamePitchClasses(hexMember) && weitzMember.type === hexMember.type)
                );
                sharedChordsDiv.innerHTML = shared.map(t => createChordSpan(t, 'purple')).join('');
            } else {
                sharedChordsDiv.innerHTML = "<p class='text-gray-500'>No hay conjuntos para comparar.</p>";
            }
        }


        // --- Visualización del Círculo ---
        
        function updateCircleVisualization(activeTriad, prevTriad = null) {
            const isRNMode = vizToggle.checked;
            
            // Actualizar título y descripción
            circleTitle.textContent = `Visualización (Ciclo ${isRNMode ? 'R/N' : 'L/P'})`;
            circleDescription.textContent = isRNMode 
                ? "Región de Weitzmann. Las operaciones L, P y H pueden llevarte a un ciclo diferente."
                : "Ciclo Hexatónico. Las operaciones R, N y S pueden llevarte a un ciclo diferente.";
            
            // Obtener el ciclo correcto
            const cycleList = isRNMode ? weitzmannCycles : hexatonicCycles;
            const op1 = isRNMode ? 'R' : 'L';
            const op2 = isRNMode ? 'N' : 'P';
            
            const foundCycle = cycleList.find(cycle => 
                cycle.members.some(member => member.hasSamePitchClasses(activeTriad) && member.type === activeTriad.type)
            );

            updateOperationButtonHighlights(); // <-- LLAMAR AL ACTUALIZAR CÍRCULO
            drawCircle(foundCycle, activeTriad, prevTriad, op1, op2);
        }

        function drawCircle(cycle, activeTriad, prevTriad = null, op1, op2) {
            hexatonicCircleSvg.innerHTML = `<defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" />
                </marker>
            </defs>`;
            
            if (!cycle || cycle.members.length === 0) {
                hexatonicCircleSvg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#64748b" class="text-xs">El acorde actual no está en este tipo de ciclo.</text>`;
                return;
            }

            const cycleChords = cycle.members;
            const centerX = 150, centerY = 150, radius = 120, nodeWidth = 60, nodeHeight = 30;

            // --- NUEVA LÓGICA DE ROTACIÓN ---
            // Encontrar el índice del acorde en el ciclo *basado en PC*, no en nombre
            const activeIndex = cycleChords.findIndex(t => t.hasSamePitchClasses(activeTriad) && t.type === activeTriad.type);
            const anglePerNode = (360 / cycleChords.length);
            const angleOffset = (activeIndex !== -1) ? (activeIndex * anglePerNode) : 0;
            // --- FIN DE LA NUEVA LÓGICA ---

            cycleChords.forEach((triad, index) => {
                const angle = ((index * anglePerNode) - angleOffset - 90) * Math.PI / 180;
                
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const node = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                node.setAttribute("x", x - nodeWidth / 2);
                node.setAttribute("y", y - nodeHeight / 2);
                node.setAttribute("width", nodeWidth);
                node.setAttribute("height", nodeHeight);
                
                const div = document.createElement("div");
                div.className = "chord-node w-full h-full flex items-center justify-center";
                
                // --- MODIFICADO ---
                // Determinar si este nodo DEL CICLO es el ACTIVO o el ANTERIOR
                const isThisNodeActive = activeTriad && triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type;
                const isThisNodePrevious = prevTriad && triad.hasSamePitchClasses(prevTriad) && triad.type === prevTriad.type;

                if (isThisNodeActive) {
                    div.textContent = activeTriad.name; // Usar la ortografía del estado actual
                    div.classList.add("active");
                } else if (isThisNodePrevious) {
                    div.textContent = prevTriad.name; // Usar la ortografía del estado anterior
                    div.classList.add("previous-active");
                } else {
                    div.textContent = triad.name; // Usar la ortografía por defecto del ciclo
                }
                // --- FIN DE MODIFICACIÓN ---
                
                node.appendChild(div);
                hexatonicCircleSvg.appendChild(node);

                // Lógica de clic para los nodos del círculo
                node.addEventListener('click', () => {
                    if (isInAnalysisMode) return; // No hacer nada si estamos en modo análisis

                    const clickedTriad = getTriadByName(triad.name);
                    if (clickedTriad.name === currentTriad.name) {
                        // Si se hace clic en el mismo acorde, solo reproducir
                        startAudioContext();
                        const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                        playVoicing(fromMidi);
                    } else {
                        // Es un nuevo acorde
                        startAudioContext();
                        const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                        const newMidiVoicing = getClosestVoicing(fromMidi, clickedTriad);
                        playVoicing(newMidiVoicing);
                        
                        previousTriad = currentTriad; // Guardar el anterior
                        currentTriad = clickedTriad;
                        
                        addHistoryEntry("Click", previousTriad, currentTriad);
                        updateUI();
                        displayOperationExplanation('');
                        removeActiveOperationHighlight();
                        removeOperationsBoxHighlight();
                    }
                });

                // Dibujar flechas
                const nextIndex = (index + 1) % cycleChords.length;
                const nextAngle = (((nextIndex * anglePerNode) - angleOffset - 90)) * Math.PI / 180;
                const nextX = centerX + radius * Math.cos(nextAngle);
                const nextY = centerY + radius * Math.sin(nextAngle);
                drawArrow(hexatonicCircleSvg, x, y, nextX, nextY, nodeWidth / 2);
            });
        }

        function drawArrow(svg, x1, y1, x2, y2, offset) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const startX = x1 + offset * Math.cos(angle);
            const startY = y1 + offset * Math.sin(angle);
            const endX = x2 - offset * Math.cos(angle);
            const endY = y2 - offset * Math.sin(angle);

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", `M ${startX} ${startY} L ${endX} ${endY}`);
            path.setAttribute("class", `arrow`);
            svg.appendChild(path);
        }

        // --- Resaltado de Botones ---

        // NUEVA FUNCIÓN para resaltar botones por ciclo
        function updateOperationButtonHighlights() {
            const isRNMode = vizToggle.checked;
            
            // Limpiar todos los resaltados de ciclo
            operationButtons.forEach(btn => {
                btn.classList.remove('btn-op-highlight-lp');
                btn.classList.remove('btn-op-highlight-rn');
            });

            if (isRNMode) {
                // Resaltar R, N, S (Ciclo R/N)
                opBtnR.classList.add('btn-op-highlight-rn');
                opBtnN.classList.add('btn-op-highlight-rn');
                opBtnS.classList.add('btn-op-highlight-rn');
            } else {
                // Resaltar L, P, H (Ciclo L/P)
                opBtnL.classList.add('btn-op-highlight-lp');
                opBtnP.classList.add('btn-op-highlight-lp');
                opBtnH.classList.add('btn-op-highlight-lp');
            }
        }

        function highlightActiveOperation(opCode) {
            removeActiveOperationHighlight();
            const button = document.querySelector(`[data-op="${opCode}"]`);
            if (button) button.classList.add('active-op-btn');
            highlightOperationsBox();
        }

        function removeActiveOperationHighlight() {
            operationButtons.forEach(button => button.classList.remove('active-op-btn'));
        }

        function highlightOperationsBox() {
            operationsBox.classList.add('operations-box-active');
        }

        function removeOperationsBoxHighlight() {
            operationsBox.classList.remove('operations-box-active');
        }

        // --- NUEVAS FUNCIONES DE ANÁLISIS GUIADO ---

        function startAnalysis(analysisKey) {
            if (!analysisKey) {
                exitAnalysis();
                return;
            }
            
            isInAnalysisMode = true;
            currentAnalysis = analysisData[analysisKey];
            currentAnalysisStep = 0;
            
            // Ocultar controles de exploración libre
            startChordContainer.classList.add('hidden');
            operationsBox.classList.add('hidden');
            freeAnalysisContainer.classList.add('hidden'); // <-- Ocultar análisis libre
            
            // Mostrar controles de análisis
            analysisControls.classList.remove('hidden');
            analysisTitle.textContent = currentAnalysis.name;
            
            // NUEVO: Cargar imagen de la partitura
            if (currentAnalysis.imageUrl) {
                analysisScoreImage.src = currentAnalysis.imageUrl;
                analysisScoreContainer.classList.remove('hidden'); // <-- NUEVO
                analysisScoreMarker.classList.remove('show'); // <-- NUEVO
            } else {
                analysisScoreContainer.classList.add('hidden'); // <-- NUEVO
            }
            
            // Cargar el primer paso
            loadAnalysisStep(0);
        }

        function loadAnalysisStep(stepIndex) {
            if (!currentAnalysis || stepIndex < 0 || stepIndex >= currentAnalysis.steps.length) {
                return; // Índice fuera de rango
            }
            
            currentAnalysisStep = stepIndex;
            const step = currentAnalysis.steps[stepIndex];
            
            const newTriad = getTriadByName(step.chord);
            if (!newTriad) {
                console.error("Acorde no encontrado en el análisis:", step.chord);
                return;
            }

            // Determinar el acorde anterior
            const prevStep = (stepIndex > 0) ? currentAnalysis.steps[stepIndex - 1] : null;
            const oldTriad = prevStep ? getTriadByName(prevStep.chord) : null;
            
            previousTriad = oldTriad;
            currentTriad = newTriad;

            // --- CÓDIGO RESTAURADO Y CORREGIDO ---
            startAudioContext();
            if (oldTriad) {
                // Si hay un acorde anterior, calcular el voice leading
                const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                const newMidiVoicing = getClosestVoicing(fromMidi, newTriad);
                updateVoicing(newMidiVoicing);
            } else {
                // Si es el primer acorde, tocarlo en la octava 4
                const rootNotes = newTriad.getNotes();
                const toneNotes = rootNotes.map(n => `${n.replace('♯', '#').replace('♭', 'b')}4`);
                const midiNotes = toneNotes.map(n => Tone.Frequency(n).toMidi());
                updateVoicing(midiNotes);
            }
            // --- FIN DEL CÓDIGO ---

            // Actualizar UI
            updateUI(); // Actualiza nombre, visualizaciones, etc.
            analysisExplanation.textContent = step.text; // Mostrar explicación

            // NUEVO: Mover el marcador de la partitura
            if (step.marker) {
                analysisScoreMarker.style.top = step.marker.top;
                analysisScoreMarker.style.left = step.marker.left;
                analysisScoreMarker.style.width = step.marker.width;
                analysisScoreMarker.style.height = step.marker.height;
                analysisScoreMarker.classList.add('show');
            } else {
                analysisScoreMarker.classList.remove('show');
            }
            
            // Resaltar la operación
            removeActiveOperationHighlight(); // Limpiar resaltado anterior
            if (step.op) {
                highlightActiveOperation(step.op);
            }

            // Actualizar historial
            if (stepIndex > 0 && oldTriad) {
                addHistoryEntry(step.op || "Siguiente", oldTriad, newTriad);
            } else {
                history = []; // Limpiar historial al inicio del análisis
                updateHistoryLog();
            }

            // Habilitar/deshabilitar botones de navegación
            prevStepBtn.disabled = (stepIndex === 0);
            nextStepBtn.disabled = (stepIndex === currentAnalysis.steps.length - 1);
        }

        function exitAnalysis() {
            isInAnalysisMode = false;
            currentAnalysis = null;
            currentAnalysisStep = 0;
            
            // Ocultar controles de análisis
            analysisControls.classList.add('hidden');
            analysisTitle.textContent = "";
            analysisExplanation.textContent = "";
            analysisSelect.value = ""; // Resetear el dropdown
            
            // NUEVO: Ocultar imagen y marcador
            analysisScoreImage.src = "";
            analysisScoreContainer.classList.add('hidden'); // <-- NUEVO
            analysisScoreMarker.classList.remove('show'); // <-- NUEVO
            
            // Mostrar controles de exploración libre
            startChordContainer.classList.remove('hidden');
            operationsBox.classList.remove('hidden');
            freeAnalysisContainer.classList.remove('hidden'); // <-- Mostrar análisis libre

            // Resetear el estado de la app (pero no el acorde actual del análisis)
            removeActiveOperationHighlight();
            removeOperationsBoxHighlight();
            history = [];
            updateHistoryLog();
        }

        // --- Event Listeners Principales ---
        
        resetButton.addEventListener("click", initializeApp);
        
        // NUEVO: Listener para el <select> de acorde inicial
        startChordSelect.addEventListener('change', (event) => {
            setStartChord(event.target.value);
        });
        
        playChordButton.addEventListener('click', () => {
            startAudioContext(); // Asegurarse de que el audio esté iniciado
            const midiNotes = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
            playVoicing(midiNotes);
        });

        // --- AÑADIDO: Listener para cambiar enarmonía ---
        mainChordDisplay.addEventListener('click', (event) => {
            // No activar si se hizo clic en el botón de play
            if (event.target.closest('#playChordButton')) {
                return;
            }
            
            if (isInAnalysisMode) return; // No cambiar enarmónicos durante el análisis

            // 1. Encontrar todos los equivalentes enarmónicos
            const equivalents = allTriads.filter(t =>
                t.type === currentTriad.type &&
                t.hasSamePitchClasses(currentTriad)
            );

            if (equivalents.length <= 1) {
                return; // No hay otros equivalentes
            }

            // --- MODIFICACIÓN ---
            const oldTriad = currentTriad; // Guardar el acorde antiguo (y su nombre)

            // 2. Encontrar el índice actual
            const currentIndex = equivalents.findIndex(t => t.name === oldTriad.name);
            
            // 3. Calcular el siguiente índice
            const nextIndex = (currentIndex + 1) % equivalents.length;
            const newTriad = equivalents[nextIndex];

            // 4. Actualizar el estado (sin historial y sin audio)
            currentTriad = newTriad; // Actualizar el estado global
            
            // 5. NUEVO: Actualizar el historial
            history.forEach(entry => {
                if (entry.from === oldTriad.name) {
                    entry.from = newTriad.name;
                }
                if (entry.to === oldTriad.name) {
                    entry.to = newTriad.name;
                }
            });

            // 6. Actualizar la UI (esto llamará a updateHistoryLog)
            updateUI(); 
            // No es una operación, así que no actualizar explicaciones ni resaltados
            // --- FIN DE MODIFICACIÓN ---
        });
        // --- FIN DE AÑADIDO ---

        // Event listener genérico para todos los botones de operación
        operationButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                if (isInAnalysisMode) return; // No hacer nada si estamos en modo análisis

                const opCode = event.target.dataset.op;
                if (!opCode) return;
                
                startAudioContext(); // Asegurarse de que el audio esté iniciado
                const oldTriad = currentTriad;
                let newTriad;

                switch (opCode) {
                    case 'L': newTriad = opL(oldTriad); break;
                    case 'P': newTriad = opP(oldTriad); break;
                    case 'R': newTriad = opR(oldTriad); break;
                    case 'N': newTriad = opN(oldTriad); break;
                    case 'H': newTriad = opH(oldTriad); break;
                    case 'S': newTriad = opS(oldTriad); break;
                }

                if (newTriad) {
                    // MODIFICADO: Audio de operación deshabilitado por solicitud del usuario
                    // const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                    // const newMidiVoicing = getClosestVoicing(fromMidi, newTriad);
                    
                    // Solo actualizar el voicing, no reproducir
                    const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                    const newMidiVoicing = getClosestVoicing(fromMidi, newTriad);
                    updateVoicing(newMidiVoicing); // <-- Actualiza el voicing para el botón de play

                    previousTriad = oldTriad; // Guardar el anterior
                    currentTriad = newTriad;
                    
                    addHistoryEntry(opCode, oldTriad, currentTriad);
                    updateUI();
                    displayOperationExplanation(opCode);
                    highlightActiveOperation(opCode);
                } else {
                    console.error("Operación", opCode, "resultó en 'null' para el acorde", oldTriad.name);
                    // Opcional: mostrar un error al usuario
                }
            });
        });
        
        // --- Listener para el Toggle Switch ---
        vizToggle.addEventListener('change', () => {
            currentVisualizationMode = vizToggle.checked ? 'rn' : 'lp';
            updateCircleVisualization(currentTriad, previousTriad);
            // updateOperationButtonHighlights(); // <-- MOVIDO a updateCircleVisualization
        });
        
        // --- Listener para los acordes en "Relación entre Conjuntos" ---
        setRelationshipsDiv.addEventListener('click', (event) => {
            if (isInAnalysisMode) return; // No hacer nada si estamos en modo análisis

            const clickedSpan = event.target.closest('[data-chord-name]');
            if (!clickedSpan) return;

            const chordName = clickedSpan.dataset.chordName;
            const triadToPlay = getTriadByName(chordName);

            if (triadToPlay && triadToPlay.name !== currentTriad.name) {
                startAudioContext(); 
                
                const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                const newMidiVoicing = getClosestVoicing(fromMidi, triadToPlay);
                playVoicing(newMidiVoicing);
                
                previousTriad = currentTriad; // Guardar el anterior
                currentTriad = triadToPlay;
                
                addHistoryEntry("Click", previousTriad, currentTriad);
                updateUI();
                displayOperationExplanation('');
                removeActiveOperationHighlight();
                removeOperationsBoxHighlight();
            
            } else if (triadToPlay && triadToPlay.name === currentTriad.name) {
                startAudioContext();
                const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                playVoicing(fromMidi);
            }
        });

        // --- NUEVOS Listeners para Análisis Guiado ---
        analysisSelect.addEventListener('change', (event) => {
            startAnalysis(event.target.value);
        });
        
        nextStepBtn.addEventListener('click', () => {
            loadAnalysisStep(currentAnalysisStep + 1);
        });
        
        prevStepBtn.addEventListener('click', () => {
            loadAnalysisStep(currentAnalysisStep - 1);
        });
        
        exitAnalysisBtn.addEventListener('click', () => {
            setStartChord(startChordSelect.value); // Salir y reiniciar al acorde seleccionado
            // initializeApp(); // Salir y reiniciar la app al estado por defecto "C Mayor"
        });

        // NUEVO: Listener para Análisis Libre
        freeAnalysisButton.addEventListener('click', () => {
            exitAnalysis(); // Asegurarse de que no estamos en modo guiado
            history = []; // Limpiar historial
            freeAnalysisError.textContent = ''; // Limpiar errores
            startAudioContext();

            const text = freeAnalysisInput.value;
            const chordNames = text.split(',').map(s => s.trim()).filter(s => s.length > 0);
            
            const triads = [];
            for (const name of chordNames) {
                const triad = getTriadByName(name);
                if (!triad) {
                    freeAnalysisError.textContent = `Error: Acorde "${name}" no reconocido.`;
                    history = []; // Limpiar historial si hay error
                    updateHistoryLog();
                    return;
                }
                triads.push(triad);
            }

            if (triads.length < 2) {
                freeAnalysisError.textContent = "Por favor, introduce al menos dos acordes.";
                return;
            }

            // Establecer el primer acorde como el punto de partida
            previousTriad = null;
            currentTriad = triads[0];
            let currentVoicing = currentTriad.getNotes().map(n => `${n.replace('♯', '#').replace('♭', 'b')}4`);
            lastPlayedVoicing = currentVoicing;
            updateVoicing(lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi()));
            
            // Iterar y analizar el resto
            for (let i = 0; i < triads.length - 1; i++) {
                const chordA = triads[i];
                const chordB = triads[i+1];
                
                const opName = findBestOperation(chordA, chordB);
                addHistoryEntry(opName, chordA, chordB);

                // Actualizar estado para el siguiente paso/UI
                previousTriad = chordA;
                currentTriad = chordB;

                // Actualizar el voicing para la siguiente iteración
                const fromMidi = lastPlayedVoicing.map(n => Tone.Frequency(n).toMidi());
                const newMidiVoicing = getClosestVoicing(fromMidi, chordB);
                updateVoicing(newMidiVoicing);
            }
            
            // Actualizar la UI al estado final de la progresión
            updateUI();
            removeActiveOperationHighlight();
            removeOperationsBoxHighlight();
        });


        // --- Carga Inicial ---
        window.onload = () => {
            populateStartChordSelect();
            initializeApp();
            drawFullTonnetz();
        };
    </script>
</body>
</html>
