<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Teoría Neo-Riemanniana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Darker text */
        }
        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn {
            @apply px-4 py-2 rounded-lg font-semibold transition-all duration-200 cursor-pointer;
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 shadow-lg transform hover:scale-105;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 shadow-md transform hover:scale-105;
        }
        /* Style for active operation button */
        .btn-secondary.active-op-btn {
            @apply bg-yellow-400 text-gray-900 border-2 border-yellow-600 shadow-xl transform scale-105;
        }

        /* Style for the operations box */
        #operationsBox {
            transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
        }
        /* New style for the active operations box */
        #operationsBox.operations-box-active {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5), 0 10px 20px -5px rgba(59, 130, 246, 0.3); /* Blue glow/shadow */
            border-color: #3b82f6; /* Brighter border */
        }

        .chord-display {
            @apply bg-blue-100 p-4 rounded-lg text-center my-4 border border-blue-200;
        }
        .history-item {
            @apply bg-gray-50 p-2 rounded-md mb-2 text-sm border border-gray-100;
        }
        .explanation-box {
            @apply bg-green-50 p-4 rounded-lg text-sm my-4 border border-green-100;
        }
        /* Custom styles for the circular visualization */
        .circle-container {
            position: relative;
            margin: 0 auto;
            border: 2px solid #cbd5e1;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8fafc; /* Lighter background for the circle */
            width: 100%; /* Fill parent width */
            height: 100%; /* Fill parent height */
        }
        .chord-node {
            position: absolute;
            width: 60px;
            height: 30px;
            background-color: #e2e8f0;
            border: 1px solid #94a3b8;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s ease-in-out, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chord-node.active {
            background-color: #3b82f6;
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 6px 12px -2px rgba(59, 130, 246, 0.4), 0 3px 7px -3px rgba(59, 130, 246, 0.3);
            animation: pulse 1.5s infinite alternate; /* Subtle pulse effect */
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.03); }
        }

        .arrow {
            position: absolute;
            stroke: #94a3b8; /* Lighter grey for default arrows */
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .arrow-active {
            stroke: #3b82f6;
            stroke-width: 3;
        }
        #arrowhead {
            fill: #94a3b8;
        }
        .arrow-active #arrowhead {
            fill: #3b82f6;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .container {
                margin: 1rem;
                padding: 1rem;
            }
            .chord-node {
                width: 50px;
                height: 25px;
                font-size: 0.65rem;
            }
            .circle-container {
                /* width: 250px; */ /* Removed fixed width */
                /* height: 250px; */ /* Removed fixed height */
            }
            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.875rem;
            }
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.2), 0 8px 15px -5px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        /* Collapsible section styles */
        .collapsible-header {
            @apply bg-blue-500 text-white p-3 rounded-lg cursor-pointer flex justify-between items-center mt-6 shadow-md;
        }
        .collapsible-header span {
            transition: transform 0.3s ease-in-out;
        }
        .collapsible-header.expanded span {
            transform: rotate(180deg);
        }
        .collapsible-content {
            @apply p-4 bg-white rounded-lg border border-gray-200 mt-2;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }
        .collapsible-content.show {
            max-height: 2000px; /* Increased for more content */
            transition: max-height 0.5s ease-in;
        }

        /* Tonnetz visualization specific styles */
        .tonnetz-node-circle { /* Renamed from .tonnetz-node to avoid conflict */
            transition: fill 0.2s ease-in-out, stroke 0.2s ease-in-out;
        }
        .tonnetz-node-circle.active {
            fill: #3b82f6;
            stroke: #1d4ed8;
        }
        .tonnetz-node-text {
            transition: fill 0.2s ease-in-out;
        }
        .tonnetz-node-text.active {
            fill: white;
            font-weight: bold;
        }
        .tonnetz-triad-outline {
            transition: stroke 0.2s ease-in-out;
        }
        .tonnetz-triad-outline.active {
            stroke: #3b82f6;
            stroke-width: 3;
        }
        .tonnetz-triad-fill {
            transition: fill 0.2s ease-in-out;
        }
    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-blue-700">Explorador de Teoría Neo-Riemanniana</h1>
        <p class="text-gray-700 mb-6 text-center">
            Bienvenido a este entorno interactivo para explorar las operaciones de la Teoría Neo-Riemanniana.
            Selecciona un acorde inicial y aplica las operaciones para ver cómo transforman las tríadas y cómo se relacionan en el espacio tonal cromático.
        </p>

        <div class="flex flex-col md:flex-row gap-6">
            <div class="md:w-1/2">
                <div class="mb-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <label for="startChord" class="block text-gray-700 text-sm font-bold mb-2">Selecciona un acorde inicial:</label>
                    <select id="startChord" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                        <!-- Options will be populated by JS -->
                    </select>
                    <button id="resetButton" class="btn btn-primary w-full mt-3">Reiniciar</button>
                </div>

                <div class="chord-display">
                    <h2 class="text-xl font-bold mb-2 text-blue-800">Acorde Actual: <span id="currentChordName">C Mayor</span></h2>
                    <p class="text-lg text-gray-700">Notas: <span id="currentChordNotes">C, E, G</span></p>
                </div>

                <div id="operationsBox" class="mb-4 p-4 bg-blue-50 rounded-lg shadow-inner border border-blue-100"> <!-- Colored box for operations -->
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Operaciones:</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                        <button id="opL" class="btn btn-secondary" data-op="L">L (Leittonechel)</button>
                        <button id="opP" class="btn btn-secondary" data-op="P">P (Parallel)</button>
                        <button id="opR" class="btn btn-secondary" data-op="R">R (Relative)</button>
                        <button id="opN" class="btn btn-secondary" data-op="N">N (Next Related)</button>
                        <button id="opH" class="btn btn-secondary" data-op="H">H (Hexatonic Pole)</button>
                        <button id="opS" class="btn btn-secondary" data-op="S">S (Slide)</button>
                    </div>
                </div>

                <div class="explanation-box">
                    <h3 class="text-lg font-semibold mb-2 text-green-800">Explicación de la Operación:</h3>
                    <p id="operationExplanation" class="text-gray-800">Selecciona una operación para ver su descripción.</p>
                </div>

                <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Historial de Transformaciones:</h3>
                    <div id="historyLog" class="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2 bg-white">
                        <!-- History items will be added here -->
                    </div>
                </div>

                <!-- New UI Section for Set Relationships -->
                <div class="p-4 bg-gray-50 rounded-lg shadow-inner mt-6">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Relación entre Conjuntos:</h3>
                    <div id="setRelationships" class="bg-white p-3 rounded-lg border border-gray-200">
                        <p class="mb-2"><strong class="text-blue-700">Ciclo Hexatónico Actual:</strong> <span id="currentHexatonicCycle"></span></p>
                        <div id="hexatonicCycleMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-green-700">Región de Weitzmann Actual:</strong> <span id="currentWeitzmannRegion"></span></p>
                        <div id="weitzmannRegionMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-purple-700">Acordes Compartidos:</strong></p>
                        <div id="sharedChords" class="flex flex-wrap gap-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Container for both visualizations -->
            <div class="md:w-1/2 flex flex-col md:flex-row gap-6"> 
                <!-- Hexatonic Cycle Visualization -->
                <div class="flex-1 p-4 flex flex-col items-center justify-center bg-white rounded-lg shadow-inner border border-blue-100 h-[400px]">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Visualización (Ciclo Hexatónico):</h3>
                    <div id="hexatonicCircle" class="circle-container w-full h-full">
                        <svg width="100%" height="100%" viewBox="0 0 300 300">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" />
                                </marker>
                            </defs>
                            <!-- Nodes will be added dynamically -->
                        </svg>
                    </div>
                    <p class="text-sm text-gray-600 mt-2 text-center">
                        Esta visualización muestra un ciclo hexatónico. El acorde activo se resaltará.
                        Las operaciones R, N y S pueden llevarte a un ciclo diferente.
                    </p>
                </div>

                <!-- Dynamic Tonnetz Visualization Section -->
                <div class="flex-1 p-4 bg-white rounded-lg shadow-inner border border-blue-100 flex flex-col items-center justify-center h-[400px]">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800 text-center">Visualización Dinámica del Tonnetz</h3>
                    <div id="tonnetzVisualization" class="w-full h-full border border-gray-200 rounded-lg bg-white flex justify-center items-center">
                        <!-- SVG Tonnetz will be drawn here dynamically -->
                    </div>
                    <p class="text-sm text-gray-600 mt-2 text-center">
                        Esta es una representación dinámica de un segmento del Tonnetz.
                        Las notas del acorde actual se resaltarán en azul (mayor) o rojo (menor).
                    </p>
                </div>
            </div>
        </div>


        <!-- Tonnetz Explanation Section -->
        <!-- Removed collapsible-header and collapsible-content for Tonnetz Explanation -->

        <p class="text-center text-gray-700 text-sm font-semibold mt-8">
            Herramienta realizada por Juan Miguel Ríos Redondo
        </p>
    </div>

    <!-- Modal for author information -->
    <div id="authorModal" class="modal-overlay">
        <div class="modal-content">
            <p class="text-gray-800 text-lg">Esta herramienta fue realizada por:</p>
            <p class="text-blue-600 text-2xl font-bold mt-2">Juan Miguel Ríos Redondo</p>
        </div>
    </div>

    <script>
        // Flag to ensure the modal only shows once per page load
        let hasModalBeenShown = false;

        // Mapping from pitch class number to note name (using sharps as primary)
        const pitchClasses = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"]; // Using Unicode sharps
        
        // Mapping from note name to pitch class number (handles both sharps and flats)
        const noteToPitchClass = {
            "C": 0, "C♯": 1, "D♭": 1, "D": 2, "D♯": 3, "E♭": 3, "E": 4, "F": 5, "F♯": 6, "G♭": 6, "G": 7, "G♯": 8, "A♭": 8, "A": 9, "A♯": 10, "B♭": 10, "B": 11
        };

        // Define a canonical spelling for each pitch class (prefer sharps by default)
        const canonicalSpelling = {
            0: "C", 1: "C♯", 2: "D", 3: "D♯", 4: "E", 5: "F",
            6: "F♯", 7: "G", 8: "G♯", 9: "A", 10: "A♯", 11: "B"
        };

        // Specific pitch class mapping for Tonnetz display notes (including enharmonic spellings as they appear in the image)
        const tonnetzNoteToPc = {
            "C": 0, "C♯": 1, "D♭": 1, "D": 2, "D♯": 3, "E♭": 3, "E": 4, "E♯": 5, "F": 5, "F♯": 6, "G♭": 6, "G": 7, "G♯": 8, "A♭": 8, "A": 9, "A♯": 10, "B♭": 10, "B": 11, "B♯": 0, "C♭": 11, "F♭": 4, "Gx": 9, "Ax": 11
        };

        // Function to normalize a pitch class (keep it within 0-11)
        function normalizePitch(pc) {
            return (pc % 12 + 12) % 12;
        }

        // Triad class
        class Triad {
            constructor(root, type) {
                this.root = root; // Note name (e.g., "C", "C#", "Db")
                this.type = type; // "major" or "minor"
                this.pitchClasses = this.calculatePitchClasses();
                this.name = `${root} ${type === 'major' ? 'Mayor' : 'menor'}`;
            }

            calculatePitchClasses() {
                const rootPc = noteToPitchClass[this.root];
                let thirdPc, fifthPc;

                if (this.type === "major") {
                    thirdPc = normalizePitch(rootPc + 4); // Major third
                    fifthPc = normalizePitch(rootPc + 7); // Perfect fifth
                } else { // minor
                    thirdPc = normalizePitch(rootPc + 3); // Minor third
                    fifthPc = normalizePitch(rootPc + 7); // Perfect fifth
                }
                return [rootPc, thirdPc, fifthPc];
            }

            getNotes() {
                const notes = [];
                
                // Root note (always use the triad's root name as is)
                notes.push(this.root);

                const thirdPc = this.pitchClasses[1];
                const fifthPc = this.pitchClasses[2];

                // Helper to get the correct enharmonic spelling based on the root of the triad
                const getNoteSpelling = (pc) => {
                    // Special cases for C# Major (E#) and F# Major (B#)
                    if (this.root === "C♯" && this.type === "major" && pc === 5) return "E♯"; // F -> E#
                    if (this.root === "F♯" && this.type === "major" && pc === 0) return "B♯"; // C -> B#

                    // Determine if we should generally prefer flat spellings for the internal notes
                    // This is a heuristic based on the root of the chord and common musical practice
                    const preferFlats = ["D♭", "E♭", "G♭", "A♭", "B♭"].includes(this.root) || // If root is explicitly flat
                                        (this.root === "F") || // F major/minor often use Bb
                                        (this.root === "C" && this.type === "minor") || // Cm uses Eb
                                        (this.root === "G" && this.type === "minor"); // Gm uses Bb

                    // Specific checks for common flat notes based on pitch class and context
                    if (pc === 11 && preferFlats) return "C♭"; // B -> Cb (e.g., in Ab minor)
                    if (pc === 4 && preferFlats) return "F♭";  // E -> Fb (e.g., in Db major)
                    if (pc === 1 && preferFlats) return "D♭";
                    if (pc === 3 && preferFlats) return "E♭";
                    if (pc === 6 && preferFlats) return "G♭";
                    if (pc === 8 && preferFlats) return "A♭";
                    if (pc === 10 && preferFlats) return "B♭";

                    // Otherwise, use canonical (sharp/natural) spelling
                    return canonicalSpelling[pc];
                };

                notes.push(getNoteSpelling(thirdPc)); // Third
                notes.push(getNoteSpelling(fifthPc)); // Fifth

                return notes;
            }

            // Checks if two triads are the same (same root and type)
            isEqual(otherTriad) {
                return this.root === otherTriad.root && this.type === otherTriad.type;
            }

            // Checks if two triads have the same pitch classes (enharmonic equivalence)
            hasSamePitchClasses(otherTriad) {
                const sortedThis = [...this.pitchClasses].sort();
                const sortedOther = [...otherTriad.pitchClasses].sort();
                return sortedThis.every((pc, i) => pc === sortedOther[i]);
            }
        }

        // Define all 12 unique root names to create all 24 triads
        const allPossibleRootNames = ["C", "C♯", "D♭", "D", "D♯", "E♭", "E", "F", "F♯", "G♭", "G", "G♯", "A♭", "A", "A♯", "B♭", "B"];

        // All possible major and minor triads (24 total) generated from allPossibleRootNames
        const allTriads = [];
        allPossibleRootNames.forEach(root => {
            if (noteToPitchClass[root] !== undefined) {
                allTriads.push(new Triad(root, "major"));
                allTriads.push(new Triad(root, "minor")); 
            }
        });

        // Helper to get a Triad object by name
        function getTriadByName(name) {
            return allTriads.find(t => t.name === name);
        }

        // --- Neo-Riemannian Operations ---
        function opL(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                newPcs = [t, f, normalizePitch(r + 11)];
                newType = "minor";
            } else {
                newPcs = [normalizePitch(f + 1), r, t];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opP(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                newPcs = [r, normalizePitch(t - 1), f];
                newType = "minor";
            } else {
                newPcs = [r, normalizePitch(t + 1), f];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opR(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                newPcs = [normalizePitch(r + 9), r, t];
                newType = "minor";
            } else {
                newPcs = [normalizePitch(r + 3), f, normalizePitch(t + 7)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opN(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                newPcs = [normalizePitch(r + 5), normalizePitch(t + 4), r];
                newType = "minor";
            } else {
                newPcs = [f, normalizePitch(r + 2), normalizePitch(t + 8)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        function opH(triad) {
            let result = opP(triad);
            result = opL(result);
            result = opP(result);
            return result;
        }

        function opS(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") {
                newPcs = [normalizePitch(r + 1), t, normalizePitch(f + 1)];
                newType = "minor";
            } else {
                newPcs = [normalizePitch(r - 1), t, normalizePitch(f - 1)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }


        // Corrected Pre-defined Hexatonic Cycles (dynamically generated for accuracy)
        const hexatonicCycles = [
            { name: "Ciclo I (C/E/G♯)", members: [] },
            { name: "Ciclo II (C♯/F/A)", members: [] },
            { name: "Ciclo III (D/F♯/B♭)", members: [] },
            { name: "Ciclo IV (D♯/G/B)", members: [] }
        ];

        function generateAndPopulateHexatonicCycle(startMajorTriad, cycleIndex) {
            const cycle = [];
            let current = startMajorTriad;
            for (let i = 0; i < 6; i++) {
                cycle.push(current);
                if (i % 2 === 0) { // Apply L
                    current = opL(current);
                } else { // Apply P
                    current = opP(current);
                }
            }
            hexatonicCycles[cycleIndex].members = cycle.filter(Boolean);
        }

        // Populate hexatonic cycles after allTriads and operations are defined
        // Ensure these starting triads exist in allTriads.
        generateAndPopulateHexatonicCycle(getTriadByName("C Mayor"), 0);
        generateAndPopulateHexatonicCycle(getTriadByName("C♯ Mayor"), 1);
        generateAndPopulateHexatonicCycle(getTriadByName("D Mayor"), 2);
        generateAndPopulateHexatonicCycle(getTriadByName("D♯ Mayor"), 3);


        // Pre-defined Weitzmann Regions
        const weitzmannRegions = [
            { name: "Región de C-E-G♯", members: [
                getTriadByName("C Mayor"), getTriadByName("C menor"),
                getTriadByName("E Mayor"), getTriadByName("E menor"),
                getTriadByName("G♯ Mayor"), getTriadByName("G♯ menor")
            ].filter(Boolean)},
            { name: "Región de C♯-F-A", members: [
                getTriadByName("C♯ Mayor"), getTriadByName("C♯ menor"),
                getTriadByName("F Mayor"), getTriadByName("F menor"),
                getTriadByName("A Mayor"), getTriadByName("A menor")
            ].filter(Boolean)},
            { name: "Región de D-F♯-B♭", members: [
                getTriadByName("D Mayor"), getTriadByName("D menor"),
                getTriadByName("F♯ Mayor"), getTriadByName("F♯ menor"),
                getTriadByName("B♭ Mayor"), getTriadByName("B♭ menor") 
            ].filter(Boolean)},
            { name: "Región de D♯-G-B", members: [
                getTriadByName("D♯ Mayor"), getTriadByName("D♯ menor"),
                getTriadByName("G Mayor"), getTriadByName("G menor"),
                getTriadByName("B Mayor"), getTriadByName("B menor")
            ].filter(Boolean)}
        ];


        // Global state
        let currentTriad;
        let history = [];
        let hexatonicCycleChords = []; // Chords for the current hexatonic cycle visualization

        // DOM Elements
        const startChordSelect = document.getElementById("startChord");
        const resetButton = document.getElementById("resetButton");
        const currentChordName = document.getElementById("currentChordName");
        const currentChordNotes = document.getElementById("currentChordNotes");
        const operationExplanation = document.getElementById("operationExplanation");
        const historyLog = document.getElementById("historyLog");
        const hexatonicCircleSvg = document.querySelector("#hexatonicCircle svg");
        const operationButtons = document.querySelectorAll('.grid button'); // All operation buttons
        const operationsBox = document.getElementById('operationsBox'); // The container for operation buttons

        // DOM elements for new Set Relationships section
        const currentHexatonicCycleSpan = document.getElementById("currentHexatonicCycle");
        const hexatonicCycleMembersDiv = document.getElementById("hexatonicCycleMembers");
        const currentWeitzmannRegionSpan = document.getElementById("currentWeitzmannRegion");
        const weitzmannRegionMembersDiv = document.getElementById("weitzmannRegionMembers");
        const sharedChordsDiv = document.getElementById("sharedChords");
        const authorModal = document.getElementById('authorModal'); // Modal element

        // Tonnetz explanation elements
        const tonnetzHeader = document.getElementById('tonnetzHeader');
        const tonnetzContent = document.getElementById('tonnetzContent');

        // New Tonnetz visualization elements
        const tonnetzVisualizerDiv = document.getElementById('tonnetzVisualization'); 
        const tonnetzSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        tonnetzSvg.setAttribute("width", "100%");
        tonnetzSvg.setAttribute("height", "100%"); // Make it fill parent
        tonnetzVisualizerDiv.appendChild(tonnetzSvg);

        // Global coordToNodeMap for quick lookup
        let coordToNodeMap = new Map();

        // Define spacing constants for the Tonnetz grid based on the image
        const P5_HORIZONTAL_SPACING = 80; // Horizontal distance for a perfect fifth
        const THIRD_VERTICAL_SPACING = 45; // Vertical distance for a major/minor third
        const THIRD_HORIZONTAL_OFFSET = P5_HORIZONTAL_SPACING / 2; // Horizontal offset for thirds

        // Define the Tonnetz nodes with their precise coordinates and note names as in the image
        // Using Unicode flat and sharp symbols for exact match with the image
        const tonnetzNodesData = [
            // Row 1: D# A# E# B# Gx
            { note: "D♯", pc: tonnetzNoteToPc["D♯"], x: 0, y: 0 },
            { note: "A♯", pc: tonnetzNoteToPc["A♯"], x: 80, y: 0 },
            { note: "E♯", pc: tonnetzNoteToPc["E♯"], x: 160, y: 0 },
            { note: "B♯", pc: tonnetzNoteToPc["B♯"], x: 240, y: 0 },
            { note: "Gx", pc: tonnetzNoteToPc["Gx"], x: 320, y: 0 },

            // Row 2: B F# C# G# D# A#
            { note: "B", pc: tonnetzNoteToPc["B"], x: -40, y: 45 },
            { note: "F♯", pc: tonnetzNoteToPc["F♯"], x: 40, y: 45 },
            { note: "C♯", pc: tonnetzNoteToPc["C♯"], x: 120, y: 45 },
            { note: "G♯", pc: tonnetzNoteToPc["G♯"], x: 200, y: 45 },
            { note: "D♯", pc: tonnetzNoteToPc["D♯"], x: 280, y: 45 },
            { note: "A♯", pc: tonnetzNoteToPc["A♯"], x: 360, y: 45 },

            // Row 3: D A E B F# C#
            { note: "D", pc: tonnetzNoteToPc["D"], x: 0, y: 90 },
            { note: "A", pc: tonnetzNoteToPc["A"], x: 80, y: 90 },
            { note: "E", pc: tonnetzNoteToPc["E"], x: 160, y: 90 },
            { note: "B", pc: tonnetzNoteToPc["B"], x: 240, y: 90 },
            { note: "F♯", pc: tonnetzNoteToPc["F♯"], x: 320, y: 90 },
            { note: "C♯", pc: tonnetzNoteToPc["C♯"], x: 400, y: 90 },

            // Row 4: Bb F C G D A
            { note: "B♭", pc: tonnetzNoteToPc["B♭"], x: -40, y: 135 },
            { note: "F", pc: tonnetzNoteToPc["F"], x: 40, y: 135 },
            { note: "C", pc: tonnetzNoteToPc["C"], x: 120, y: 135 },
            { note: "G", pc: tonnetzNoteToPc["G"], x: 200, y: 135 },
            { note: "D", pc: tonnetzNoteToPc["D"], x: 280, y: 135 },
            { note: "A", pc: tonnetzNoteToPc["A"], x: 360, y: 135 },

            // Row 5: Db Ab Eb Bb F C
            { note: "D♭", pc: tonnetzNoteToPc["D♭"], x: 0, y: 180 },
            { note: "A♭", pc: tonnetzNoteToPc["A♭"], x: 80, y: 180 },
            { note: "E♭", pc: tonnetzNoteToPc["E♭"], x: 160, y: 180 },
            { note: "B♭", pc: tonnetzNoteToPc["B♭"], x: 240, y: 180 },
            { note: "F", pc: tonnetzNoteToPc["F"], x: 320, y: 180 },
            { note: "C", pc: tonnetzNoteToPc["C"], x: 400, y: 180 },

            // Row 6: Ax Fb Cb Gb Db Ab
            { note: "Ax", pc: tonnetzNoteToPc["Ax"], x: -40, y: 225 },
            { note: "F♭", pc: tonnetzNoteToPc["F♭"], x: 40, y: 225 },
            { note: "C♭", pc: tonnetzNoteToPc["C♭"], x: 120, y: 225 },
            { note: "G♭", pc: tonnetzNoteToPc["G♭"], x: 200, y: 225 },
            { note: "D♭", pc: tonnetzNoteToPc["D♭"], x: 280, y: 225 },
            { note: "A♭", pc: tonnetzNoteToPc["A♭"], x: 360, y: 225 },
        ];


        // Explanations for operations
        const explanations = {
            "L": "La operación **L (Leittonechel / Intercambio de Tono Principal)** transforma una tríada mayor en una menor (y viceversa) moviendo una voz por semitono. Por ejemplo, C Mayor (C-E-G) → L E menor (E-G-B).",
            "P": "La operación **P (Parallel / Paralelo)** transforma una tríada mayor en su paralela menor (y viceversa) manteniendo la tónica y la quinta, y moviendo la tercera un semitono. Por ejemplo, C Mayor (C-E-G) → P C menor (C-E♭-G).",
            "R": "La operación **R (Relative / Relativo)** transforma una tríada mayor en su relativa menor (o viceversa) moviendo la tónica o la quinta un tono. Por ejemplo, C Mayor (C-E-G) → R A menor (A-C-E).",
            "N": "La operación **N (Next Related / Próximo Relacionado)** transforma una tríada mayor en una menor (y viceversa) moviendo dos voces por semitono. Por ejemplo, C Mayor (C-E-G) → N F menor (F-A♭-C).",
            "H": "La operación **H (Hexatonic Pole / Polo Hexatónico)** es una operación compuesta (PLP o LPL) que conecta dos tríadas dentro del mismo ciclo hexatónico que no comparten ninguna nota. Por ejemplo, C Mayor → H A♭ menor (A♭-C♭-E♭).",
            "S": "La operación **S (Slide / Deslizamiento)** transforma una tríada mayor en una menor (y viceversa) moviendo la tónica y la quinta un semitono en la misma dirección. Por ejemplo, C Mayor (C-E-G) → S C♯ menor (C♯-E-G♯)."
        };

        // Function to display operation explanation
        function displayOperationExplanation(opCode) {
            operationExplanation.innerHTML = explanations[opCode] || "Selecciona una operación para ver su descripción.";
        }

        // Function to show the author modal
        function showAuthorModal() {
            if (!hasModalBeenShown) {
                authorModal.classList.add('show');
                setTimeout(() => {
                    authorModal.classList.remove('show');
                }, 4000); // Hide after 4 seconds
                hasModalBeenShown = true; // Set flag to true after showing
            }
        }

        // Helper to draw a line in SVG
        function drawLine(svg, p1, p2, color, strokeWidth = "1") {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", p1.x);
            line.setAttribute("y1", p1.y);
            line.setAttribute("x2", p2.x);
            line.setAttribute("y2", p2.y);
            line.setAttribute("stroke", color);
            line.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(line);
        }

        function drawFullTonnetz() {
            tonnetzSvg.innerHTML = ''; // Clear existing content

            // Create a map for quick lookup by coordinates
            coordToNodeMap = new Map(); // Re-initialize global map
            tonnetzNodesData.forEach(node => {
                coordToNodeMap.set(`${node.x},${node.y}`, node);
            });

            // Draw connections first (lines)
            tonnetzNodesData.forEach(node => {
                // Check for P5 right neighbor (horizontal)
                const p5RightCoord = `${node.x + P5_HORIZONTAL_SPACING},${node.y}`;
                const p5RightNode = coordToNodeMap.get(p5RightCoord);
                if (p5RightNode) {
                    drawLine(tonnetzSvg, node, p5RightNode, "#cbd5e1");
                }

                // Check for M3 up-right neighbor (diagonal)
                const m3UpRightCoord = `${node.x + THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`;
                const m3UpRightNode = coordToNodeMap.get(m3UpRightCoord);
                if (m3UpRightNode) {
                    drawLine(tonnetzSvg, node, m3UpRightNode, "#cbd5e1");
                }

                // Check for m3 up-left neighbor (diagonal)
                const m3UpLeftCoord = `${node.x - THIRD_HORIZONTAL_OFFSET},${node.y - THIRD_VERTICAL_SPACING}`;
                const m3UpLeftNode = coordToNodeMap.get(m3UpLeftCoord);
                if (m3UpLeftNode) {
                    drawLine(tonnetzSvg, node, m3UpLeftNode, "#cbd5e1");
                }
            });

            // Draw nodes (circles and text) on top of lines
            tonnetzNodesData.forEach(pos => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", pos.x);
                circle.setAttribute("cy", pos.y);
                circle.setAttribute("r", 15);
                circle.setAttribute("fill", "#e2e8f0");
                circle.setAttribute("stroke", "#94a3b8");
                circle.setAttribute("stroke-width", "1");
                circle.classList.add("tonnetz-node-circle"); // Renamed class
                circle.dataset.note = pos.note; // Store the exact note name for highlighting

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", pos.x);
                text.setAttribute("y", pos.y + 5);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-size", "10");
                text.setAttribute("fill", "#475569");
                text.textContent = pos.note; // Use the exact note name from tonnetzNodesData
                text.classList.add("tonnetz-node-text");
                text.dataset.note = pos.note;

                tonnetzSvg.appendChild(circle);
                tonnetzSvg.appendChild(text);
            });

            // Update viewBox to fit the generated content
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            tonnetzNodesData.forEach(node => {
                minX = Math.min(minX, node.x - 15); // Node radius
                minY = Math.min(minY, node.y - 15);
                maxX = Math.max(maxX, node.x + 15);
                maxY = Math.max(maxY, node.y + 15);
            });
            const padding = 20; // Extra padding for the viewBox
            const finalWidth = maxX - minX + 2 * padding;
            const finalHeight = maxY - minY + 2 * padding;
            tonnetzSvg.setAttribute("viewBox", `${minX - padding} ${minY - padding} ${finalWidth} ${finalHeight}`);
        }


        // Update highlightTonnetzTriad to use the new tonnetzGrid
        function highlightTonnetzTriad(triad) {
            // Remove existing highlights
            tonnetzSvg.querySelectorAll('.tonnetz-node-circle.active').forEach(node => node.classList.remove('active'));
            tonnetzSvg.querySelectorAll('.tonnetz-node-text.active').forEach(node => node.classList.remove('active'));
            tonnetzSvg.querySelectorAll('.tonnetz-triad-fill').forEach(fill => fill.remove()); // Remove dynamic fill

            const triadPcs = triad.pitchClasses; // These are 0-11 pitch classes

            // Highlight nodes that match the triad's pitch classes (reverted to previous behavior)
            triadPcs.forEach(pc => {
                // Find all notes in tonnetzNodesData that have this pitch class
                const matchingTonnetzNodes = tonnetzNodesData.filter(node => node.pc === pc);

                matchingTonnetzNodes.forEach(tonnetzNode => {
                    tonnetzSvg.querySelectorAll(`.tonnetz-node-circle[data-note="${tonnetzNode.note}"]`).forEach(node => node.classList.add('active'));
                    tonnetzSvg.querySelectorAll(`.tonnetz-node-text[data-note="${tonnetzNode.note}"]`).forEach(node => node.classList.add('active'));
                });
            });

            // Draw and highlight the triad triangle
            const rootPc = triad.pitchClasses[0];
            const thirdPc = triad.pitchClasses[1];
            const fifthPc = triad.pitchClasses[2];

            let foundTriadNodes = [];

            // Iterate through all nodes that match the root's pitch class to find the correct triangle
            const possibleRootNodes = tonnetzNodesData.filter(node => node.pc === rootPc);

            for (const pRootNode of possibleRootNodes) {
                let pThirdNode = null;
                let pFifthNode = null;

                if (triad.type === "major") {
                    // Expected Major Third position (up-right)
                    const m3UpRightCoord = `${pRootNode.x + THIRD_HORIZONTAL_OFFSET},${pRootNode.y - THIRD_VERTICAL_SPACING}`;
                    pThirdNode = coordToNodeMap.get(m3UpRightCoord);
                    // Expected Perfect Fifth position (right)
                    const p5RightCoord = `${pRootNode.x + P5_HORIZONTAL_SPACING},${pRootNode.y}`;
                    pFifthNode = coordToNodeMap.get(p5RightCoord);
                } else { // minor
                    // Expected Minor Third position (up-left)
                    const m3UpLeftCoord = `${pRootNode.x - THIRD_HORIZONTAL_OFFSET},${pRootNode.y - THIRD_VERTICAL_SPACING}`;
                    pThirdNode = coordToNodeMap.get(m3UpLeftCoord);
                    // Expected Perfect Fifth position (right)
                    const p5RightCoord = `${pRootNode.x + P5_HORIZONTAL_SPACING},${pRootNode.y}`;
                    pFifthNode = coordToNodeMap.get(p5RightCoord);
                }

                // Check if the found nodes exist and have the correct pitch classes
                if (pThirdNode && pFifthNode &&
                    pThirdNode.pc === thirdPc && pFifthNode.pc === fifthPc) {
                    foundTriadNodes = [pRootNode, pThirdNode, pFifthNode];
                    break; // Found the correct set of nodes for the triangle
                }
            }

            if (foundTriadNodes.length === 3) {
                const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                // Sort coords by x then y to ensure consistent drawing order for polygon
                foundTriadNodes.sort((a, b) => {
                    if (a.x !== b.x) return a.x - b.x;
                    return a.y - b.y;
                });
                polygon.setAttribute("points", `${foundTriadNodes[0].x},${foundTriadNodes[0].y} ${foundTriadNodes[1].x},${foundTriadNodes[1].y} ${foundTriadNodes[2].x},${foundTriadNodes[2].y}`);
                polygon.setAttribute("fill", triad.type === 'major' ? "rgba(255, 0, 0, 0.4)" : "rgba(0, 0, 255, 0.4)"); // Red for major, blue for minor, slightly more opaque
                polygon.setAttribute("stroke", triad.type === 'major' ? "red" : "blue");
                polygon.setAttribute("stroke-width", "3");
                polygon.classList.add("tonnetz-triad-fill");
                tonnetzSvg.prepend(polygon); // Add to the beginning so it's behind notes/lines
            }
        }


        // Populate initial chord options
        function populateStartChordSelect() {
            // Define a canonical order for roots in the dropdown
            const orderedRoots = [
                "C", "D♭", "D", "E♭", "E", "F", "F♯", "G", "A♭", "A", "B♭", "B"
            ];
            
            // Create a temporary list of triads to populate the dropdown, ensuring no duplicates
            const dropdownTriads = [];
            const addedNames = new Set(); // To track names already added

            // Iterate through the ordered roots to ensure consistent dropdown order
            orderedRoots.forEach(rootName => {
                // Find major and minor triads for this root
                const majorTriad = allTriads.find(t => t.root === rootName && t.type === "major");
                const minorTriad = allTriads.find(t => t.root === rootName && t.type === "minor");

                if (majorTriad && !addedNames.has(majorTriad.name)) {
                    dropdownTriads.push(majorTriad);
                    addedNames.add(majorTriad.name);
                }
                if (minorTriad && !addedNames.has(minorTriad.name)) {
                    dropdownTriads.push(minorTriad);
                    addedNames.add(minorTriad.name);
                }
            });

            // Sort the final list for the dropdown
            const sortedDropdownTriads = [...dropdownTriads].sort((a, b) => {
                const indexA = orderedRoots.indexOf(a.root);
                const indexB = orderedRoots.indexOf(b.root);

                if (indexA !== indexB) {
                    return indexA - indexB;
                }
                return a.type.localeCompare(b.type); // Major before minor
            });

            sortedDropdownTriads.forEach(triad => {
                const option = document.createElement("option");
                option.value = triad.name;
                option.textContent = triad.name;
                startChordSelect.appendChild(option);
            });
            startChordSelect.value = "C Mayor";
        }

        // Initialize or reset the application state
        function initializeApp() {
            try {
                const selectedTriadName = startChordSelect.value;
                currentTriad = allTriads.find(t => t.name === selectedTriadName);
                if (!currentTriad) {
                    console.error("Error: Initial triad not found for name:", selectedTriadName);
                    // Fallback to a default if the selected one is not found
                    currentTriad = getTriadByName("C Mayor");
                    if (!currentTriad) {
                        console.error("Critical Error: C Mayor not found. Cannot initialize.");
                        document.body.innerHTML = "<p style='color: red; text-align: center; margin-top: 50px;'>Error crítico al cargar la aplicación. Por favor, recarga.</p>";
                        return;
                    }
                }
                history = [];
                updateUI();
                updateHexatonicCircleVisualization(currentTriad);
                displayOperationExplanation(''); // Clear explanation on reset
                removeActiveOperationHighlight(); // Clear any highlighted operation button
                removeOperationsBoxHighlight(); // Clear operations box highlight
                
                // Only show modal if it hasn't been shown before (first page load)
                showAuthorModal(); 

            } catch (error) {
                console.error("Error during application initialization:", error);
                document.body.innerHTML = "<p style='color: red; text-align: center; margin-top: 50px;'>Ha ocurrido un error al cargar la aplicación. Por favor, inténtalo de nuevo.</p>";
            }
        }

        // Update the UI with current triad information
        function updateUI() {
            currentChordName.textContent = currentTriad.name;
            const notes = currentTriad.getNotes();
            currentChordNotes.innerHTML = `Raíz: <span class="font-bold">${notes[0]}</span>, Tercera: <span class="font-bold">${notes[1]}</span>, Quinta: <span class="font-bold">${notes[2]}</span>`;
            updateHistoryLog();
            highlightHexatonicNode(currentTriad);
            updateSetRelationshipsDisplay();
            highlightTonnetzTriad(currentTriad); // Call to update the new Tonnetz visualization
        }

        // Add an entry to the history log
        function addHistoryEntry(operationName, oldTriad, newTriad) {
            const entry = {
                operation: operationName,
                from: oldTriad.name,
                to: newTriad.name,
                timestamp: new Date().toLocaleTimeString()
            };
            history.push(entry);
            historyLog.scrollTop = historyLog.scrollHeight;
        }

        // Render the history log
        function updateHistoryLog() {
            historyLog.innerHTML = "";
            if (history.length === 0) {
                historyLog.innerHTML = "<p class='text-gray-500'>No hay transformaciones aún.</p>";
                return;
            }
            history.forEach(entry => {
                const div = document.createElement("div");
                div.className = "history-item";
                div.textContent = `${entry.timestamp}: ${entry.from} --(${entry.operation})--> ${entry.to}`;
                historyLog.appendChild(div);
            });
        }

        // Helper to find a triad by its pitch classes (for operations that might generate new note names)
        function findTriadByPitchClasses(pcs, type) {
            const sortedPcs = [...pcs].sort();
            for (const triad of allTriads) {
                const sortedTriadPcs = [...triad.pitchClasses].sort();
                if (triad.type === type && sortedPcs.every((pc, i) => pc === sortedTriadPcs[i])) {
                    return triad;
                }
            }
            return null;
        }

        // --- Set Relationship Functions ---
        function getHexatonicCycleForTriad(triad) {
            for (const cycle of hexatonicCycles) {
                if (cycle.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return cycle;
                }
            }
            return null;
        }

        function getWeitzmannRegionForTriad(triad) {
            for (const region of weitzmannRegions) {
                if (region.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return region;
                }
            }
            return null;
        }

        function updateSetRelationshipsDisplay() {
            const hexCycle = getHexatonicCycleForTriad(currentTriad);
            const weitzRegion = getWeitzmannRegionForTriad(currentTriad); // Corrected typo here

            if (hexCycle) {
                currentHexatonicCycleSpan.textContent = hexCycle.name;
                hexatonicCycleMembersDiv.innerHTML = hexCycle.members.map(t => `<span class="bg-blue-100 text-blue-800 px-2 py-1 rounded-md">${t.name}</span>`).join('');
            } else {
                currentHexatonicCycleSpan.textContent = "No encontrado";
                hexatonicCycleMembersDiv.innerHTML = "";
            }

            if (weitzRegion) {
                currentWeitzmannRegionSpan.textContent = weitzRegion.name;
                weitzmannRegionMembersDiv.innerHTML = weitzRegion.members.map(t => `<span class="bg-green-100 text-green-800 px-2 py-1 rounded-md">${t.name}</span>`).join('');
            } else {
                currentWeitzmannRegionSpan.textContent = "No encontrado";
                weitzmannRegionMembersDiv.innerHTML = "";
            }

            if (hexCycle && weitzRegion) {
                const shared = hexCycle.members.filter(hexMember =>
                    weitzRegion.members.some(weitzMember => weitzMember.hasSamePitchClasses(hexMember) && weitzMember.type === hexMember.type)
                );
                sharedChordsDiv.innerHTML = shared.map(t => `<span class="bg-purple-100 text-purple-800 px-2 py-1 rounded-md">${t.name}</span>`).join('');
            } else {
                sharedChordsDiv.innerHTML = "<p class='text-gray-500'>No hay conjuntos para comparar.</p>";
            }
        }


        // --- Hexatonic Cycle Visualization ---
        function updateHexatonicCircleVisualization(activeTriad) {
            hexatonicCircleSvg.innerHTML = `<defs>
                                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                                    <polygon points="0 0, 10 3.5, 0 7" />
                                                </marker>
                                            </defs>`;

            const foundCycle = getHexatonicCycleForTriad(activeTriad);

            if (!foundCycle) {
                hexatonicCircleSvg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#64748b" class="text-xs">El acorde actual no está en el ciclo hexatónico visualizado.</text>`;
                hexatonicCycleChords = [];
                return;
            }

            hexatonicCycleChords = foundCycle.members;

            const centerX = 150;
            const centerY = 150;
            const radius = 120;
            const nodeWidth = 60;
            const nodeHeight = 30;

            hexatonicCycleChords.forEach((triad, index) => {
                const angle = (index * (360 / hexatonicCycleChords.length) - 90) * Math.PI / 180;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const node = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                node.setAttribute("x", x - nodeWidth / 2);
                node.setAttribute("y", y - nodeHeight / 2);
                node.setAttribute("width", nodeWidth);
                node.setAttribute("height", nodeHeight);
                node.classList.add("chord-node");
                if (triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type) {
                    node.classList.add("active");
                }
                node.innerHTML = `<div class="w-full h-full flex items-center justify-center">${triad.name}</div>`;
                hexatonicCircleSvg.appendChild(node);

                node.addEventListener('click', () => {
                    currentTriad = getTriadByName(triad.name);
                    history = [];
                    updateUI();
                    updateHexatonicCircleVisualization(currentTriad);
                    displayOperationExplanation('');
                    removeActiveOperationHighlight();
                    removeOperationsBoxHighlight();
                });

                const nextIndex = (index + 1) % hexatonicCycleChords.length;
                const nextTriad = hexatonicCycleChords[nextIndex];

                const nextAngle = (nextIndex * (360 / hexatonicCycleChords.length) - 90) * Math.PI / 180;
                const nextX = centerX + radius * Math.cos(nextAngle);
                const nextY = centerY + radius * Math.sin(nextAngle);

                let isArrowActive = false;
                if (triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type) {
                    const expectedNextByL = opL(triad);
                    const expectedNextByP = opP(triad);

                    if (expectedNextByL && expectedNextByL.hasSamePitchClasses(nextTriad) && expectedNextByL.type === nextTriad.type) {
                        isArrowActive = true;
                    } else if (expectedNextByP && expectedNextByP.hasSamePitchClasses(nextTriad) && expectedNextByP.type === nextTriad.type) {
                        isArrowActive = true;
                    }
                }

                drawArrow(hexatonicCircleSvg, x, y, nextX, nextY, nodeWidth / 2, isArrowActive);
            });
        }

        function drawArrow(svg, x1, y1, x2, y2, offset, isActive = false) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const startX = x1 + offset * Math.cos(angle);
            const startY = y1 + offset * Math.sin(angle);
            const endX = x2 - offset * Math.cos(angle);
            const endY = y2 - offset * Math.sin(angle);

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", `M ${startX} ${startY} L ${endX} ${endY}`);
            path.setAttribute("class", `arrow ${isActive ? 'arrow-active' : ''}`);
            svg.appendChild(path);
        }

        function highlightHexatonicNode(triadToHighlight) {
            document.querySelectorAll('.chord-node').forEach(node => {
                node.classList.remove('active');
            });
            const index = hexatonicCycleChords.findIndex(t => t.hasSamePitchClasses(triadToHighlight) && t.type === triadToHighlight.type);
            if (index !== -1) {
                const nodeElement = hexatonicCircleSvg.children[index + 1];
                if (nodeElement) {
                    nodeElement.classList.add('active');
                }
            }
        }

        // Function to highlight the active operation button
        function highlightActiveOperation(opCode) {
            removeActiveOperationHighlight();
            const button = document.querySelector(`[data-op="${opCode}"]`);
            if (button) {
                button.classList.add('active-op-btn');
            }
            highlightOperationsBox();
        }

        // Function to remove all active operation button highlights
        function removeActiveOperationHighlight() {
            operationButtons.forEach(button => {
                button.classList.remove('active-op-btn');
            });
        }

        // Function to highlight the operations box
        function highlightOperationsBox() {
            operationsBox.classList.add('operations-box-active');
        }

        // Function to remove operations box highlight
        function removeOperationsBoxHighlight() {
            operationsBox.classList.remove('operations-box-active');
        }


        // Event Listeners
        resetButton.addEventListener("click", initializeApp);

        document.getElementById("opL").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opL(currentTriad);
            addHistoryEntry("L", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("L");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opP").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opP(currentTriad);
            addHistoryEntry("P", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("P");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opR").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opR(currentTriad);
            addHistoryEntry("R", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("R");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opN").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opN(currentTriad);
            addHistoryEntry("N", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("N");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opH").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opH(currentTriad);
            addHistoryEntry("H", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("H");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opS").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opS(currentTriad);
            addHistoryEntry("S", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("S");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        // Initial setup on page load
        window.onload = () => {
            populateStartChordSelect();
            initializeApp();
            drawFullTonnetz(); // Draw the new dynamic Tonnetz visualization
        };
    </script>
</body>
</html>


