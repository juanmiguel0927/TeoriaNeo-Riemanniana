<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Teoría Neo-Riemanniana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Darker text */
        }
        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn {
            @apply px-4 py-2 rounded-lg font-semibold transition-all duration-200 cursor-pointer;
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 shadow-lg transform hover:scale-105;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 shadow-md transform hover:scale-105;
        }
        /* Style for active operation button */
        .btn-secondary.active-op-btn {
            @apply bg-yellow-400 text-gray-900 border-2 border-yellow-600 shadow-xl transform scale-105;
        }

        /* Style for the operations box */
        #operationsBox {
            transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
        }
        /* New style for the active operations box */
        #operationsBox.operations-box-active {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5), 0 10px 20px -5px rgba(59, 130, 246, 0.3); /* Blue glow/shadow */
            border-color: #3b82f6; /* Brighter border */
        }

        .chord-display {
            @apply bg-blue-100 p-4 rounded-lg text-center my-4 border border-blue-200;
        }
        .history-item {
            @apply bg-gray-50 p-2 rounded-md mb-2 text-sm border border-gray-100;
        }
        .explanation-box {
            @apply bg-green-50 p-4 rounded-lg text-sm my-4 border border-green-100;
        }
        /* Custom styles for the circular visualization */
        .circle-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto;
            border: 2px solid #cbd5e1;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8fafc; /* Lighter background for the circle */
        }
        .chord-node {
            position: absolute;
            width: 60px;
            height: 30px;
            background-color: #e2e8f0;
            border: 1px solid #94a3b8;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s ease-in-out, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chord-node.active {
            background-color: #3b82f6;
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 6px 12px -2px rgba(59, 130, 246, 0.4), 0 3px 7px -3px rgba(59, 130, 246, 0.3);
            animation: pulse 1.5s infinite alternate; /* Subtle pulse effect */
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.03); }
        }

        .arrow {
            position: absolute;
            stroke: #94a3b8; /* Lighter grey for default arrows */
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .arrow-active {
            stroke: #3b82f6;
            stroke-width: 3;
        }
        #arrowhead {
            fill: #94a3b8;
        }
        .arrow-active #arrowhead {
            fill: #3b82f6;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .container {
                margin: 1rem;
                padding: 1rem;
            }
            .chord-node {
                width: 50px;
                height: 25px;
                font-size: 0.65rem;
            }
            .circle-container {
                width: 250px;
                height: 250px;
            }
            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.875rem;
            }
        }
    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-blue-700">Explorador de Teoría Neo-Riemanniana</h1>
        <p class="text-gray-700 mb-6 text-center">
            Bienvenido a este entorno interactivo para explorar las operaciones de la Teoría Neo-Riemanniana.
            Selecciona un acorde inicial y aplica las operaciones para ver cómo transforman las tríadas y cómo se relacionan en el espacio tonal cromático.
        </p>

        <div class="flex flex-col md:flex-row gap-6">
            <div class="md:w-1/2">
                <div class="mb-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <label for="startChord" class="block text-gray-700 text-sm font-bold mb-2">Selecciona un acorde inicial:</label>
                    <select id="startChord" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                        <!-- Options will be populated by JS -->
                    </select>
                    <button id="resetButton" class="btn btn-primary w-full mt-3">Reiniciar</button>
                </div>

                <div class="chord-display">
                    <h2 class="text-xl font-bold mb-2 text-blue-800">Acorde Actual: <span id="currentChordName">C Mayor</span></h2>
                    <p class="text-lg text-gray-700">Notas: <span id="currentChordNotes">C, E, G</span></p>
                </div>

                <div id="operationsBox" class="mb-4 p-4 bg-blue-50 rounded-lg shadow-inner border border-blue-100"> <!-- Colored box for operations -->
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Operaciones:</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                        <button id="opL" class="btn btn-secondary" data-op="L">L (Leittonechel)</button>
                        <button id="opP" class="btn btn-secondary" data-op="P">P (Parallel)</button>
                        <button id="opR" class="btn btn-secondary" data-op="R">R (Relative)</button>
                        <button id="opN" class="btn btn-secondary" data-op="N">N (Next Related)</button>
                        <button id="opH" class="btn btn-secondary" data-op="H">H (Hexatonic Pole)</button>
                        <button id="opS" class="btn btn-secondary" data-op="S">S (Slide)</button>
                    </div>
                </div>

                <div class="explanation-box">
                    <h3 class="text-lg font-semibold mb-2 text-green-800">Explicación de la Operación:</h3>
                    <p id="operationExplanation" class="text-gray-800">Selecciona una operación para ver su descripción.</p>
                </div>

                <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Historial de Transformaciones:</h3>
                    <div id="historyLog" class="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2 bg-white">
                        <!-- History items will be added here -->
                    </div>
                </div>

                <!-- New UI Section for Set Relationships -->
                <div class="p-4 bg-gray-50 rounded-lg shadow-inner mt-6">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Relación entre Conjuntos:</h3>
                    <div id="setRelationships" class="bg-white p-3 rounded-lg border border-gray-200">
                        <p class="mb-2"><strong class="text-blue-700">Ciclo Hexatónico Actual:</strong> <span id="currentHexatonicCycle"></span></p>
                        <div id="hexatonicCycleMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-green-700">Región de Weitzmann Actual:</strong> <span id="currentWeitzmannRegion"></span></p>
                        <div id="weitzmannRegionMembers" class="flex flex-wrap gap-2 text-sm"></div>
                        <p class="mt-4 mb-2"><strong class="text-purple-700">Acordes Compartidos:</strong></p>
                        <div id="sharedChords" class="flex flex-wrap gap-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <div class="md:w-1/2 flex flex-col items-center justify-center p-4">
                <h3 class="text-lg font-semibold mb-3 text-gray-800">Visualización (Ciclo Hexatónico):</h3>
                <div id="hexatonicCircle" class="circle-container">
                    <svg width="100%" height="100%" viewBox="0 0 300 300">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" />
                            </marker>
                        </defs>
                        <!-- Nodes will be added dynamically -->
                    </svg>
                </div>
                <p class="text-sm text-gray-600 mt-2 text-center">
                    Esta visualización muestra un ciclo hexatónico. El acorde activo se resaltará.
                    Las operaciones R, N y S pueden llevarte a un ciclo diferente.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Mapping from pitch class number to note name (using sharps as primary)
        const pitchClasses = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // Mapping from note name to pitch class number (handles both sharps and flats)
        const noteToPitchClass = {
            "C": 0, "C#": 1, "Db": 1, "D": 2, "D#": 3, "Eb": 3, "E": 4, "F": 5, "F#": 6, "Gb": 6, "G": 7, "G#": 8, "Ab": 8, "A": 9, "A#": 10, "Bb": 10, "B": 11
        };

        // Function to normalize a pitch class (keep it within 0-11)
        function normalizePitch(pc) {
            return (pc % 12 + 12) % 12;
        }

        // Triad class
        class Triad {
            constructor(root, type) {
                this.root = root; // Note name (e.g., "C", "C#", "Db")
                this.type = type; // "major" or "minor"
                this.pitchClasses = this.calculatePitchClasses();
                this.name = `${root} ${type === 'major' ? 'Mayor' : 'menor'}`;
            }

            calculatePitchClasses() {
                const rootPc = noteToPitchClass[this.root];
                let thirdPc, fifthPc;

                if (this.type === "major") {
                    thirdPc = normalizePitch(rootPc + 4); // Major third
                    fifthPc = normalizePitch(rootPc + 7); // Perfect fifth
                } else { // minor
                    thirdPc = normalizePitch(rootPc + 3); // Minor third
                    fifthPc = normalizePitch(rootPc + 7); // Perfect fifth
                }
                return [rootPc, thirdPc, fifthPc];
            }

            getNotes() {
                const notes = [];
                
                // Root note (always use the triad's root name as is)
                notes.push(this.root);

                const thirdPc = this.pitchClasses[1];
                const fifthPc = this.pitchClasses[2];

                // Helper to get the correct enharmonic spelling based on the root of the triad
                const getCorrectSpelling = (pc, rootNote) => {
                    // Default to sharp spelling from pitchClasses array
                    let noteName = pitchClasses[pc];

                    // Special cases for C# Major (E#) and F# Major (B#)
                    if (rootNote === "C#" && pc === 5) return "E#"; // F -> E#
                    if (rootNote === "F#" && pc === 0) return "B#"; // C -> B#

                    // If the root is a flat, or if it's a natural root that commonly leads to flat spellings (like G, C, F),
                    // prefer flat spellings for other notes.
                    if (rootNote.includes("b") || ["G", "C", "F"].includes(rootNote)) {
                        if (pc === 1) return "Db";
                        else if (pc === 3) return "Eb";
                        else if (pc === 6) return "Gb";
                        else if (pc === 8) return "Ab";
                        else if (pc === 10) return "Bb";
                    }
                    // Otherwise (sharp or other natural roots), prefer sharp spellings.
                    else {
                        if (pc === 1) return "C#";
                        else if (pc === 3) return "D#";
                        else if (pc === 6) return "F#";
                        else if (pc === 8) return "G#";
                        else if (pc === 10) return "A#";
                    }
                    return noteName;
                };

                notes.push(getCorrectSpelling(thirdPc, this.root));
                notes.push(getCorrectSpelling(fifthPc, this.root));

                return notes;
            }

            // Checks if two triads are the same (same root and type)
            isEqual(otherTriad) {
                return this.root === otherTriad.root && this.type === otherTriad.type;
            }

            // Checks if two triads have the same pitch classes (enharmonic equivalence)
            hasSamePitchClasses(otherTriad) {
                const sortedThis = [...this.pitchClasses].sort();
                const sortedOther = [...otherTriad.pitchClasses].sort();
                return sortedThis.every((pc, i) => pc === sortedOther[i]);
            }
        }

        // Define all 12 unique root names using sharps as primary for the dropdown,
        // but include common flat spellings for internal Triad creation if needed.
        const allPossibleRootNames = ["C", "C#", "Db", "D", "D#", "Eb", "E", "F", "F#", "Gb", "G", "G#", "Ab", "A", "A#", "Bb", "B"];

        // All possible major and minor triads (24 total) generated from allPossibleRootNames
        const allTriads = [];
        allPossibleRootNames.forEach(root => {
            // Only create triad if the root name maps to a valid pitch class
            if (noteToPitchClass[root] !== undefined) {
                allTriads.push(new Triad(root, "major"));
                allTriads.push(new Triad(root, "minor"));
            }
        });

        // Helper to get a Triad object by name
        function getTriadByName(name) {
            return allTriads.find(t => t.name === name);
        }

        // --- Neo-Riemannian Operations (re-defined for clarity and to ensure consistency) ---
        // L (Leittonechel - Leading-tone exchange)
        function opL(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C Mayor (0,4,7) -> E menor (4,7,11)
                newPcs = [t, f, normalizePitch(r + 11)];
                newType = "minor";
            } else { // C menor (0,3,7) -> Ab Mayor (8,0,3)
                newPcs = [normalizePitch(f + 1), r, t];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        // P (Parallel)
        function opP(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C Mayor (0,4,7) -> C menor (0,3,7)
                newPcs = [r, normalizePitch(t - 1), f];
                newType = "minor";
            } else { // C menor (0,3,7) -> C Mayor (0,4,7)
                newPcs = [r, normalizePitch(t + 1), f];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        // R (Relative)
        function opR(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C Mayor (0,4,7) -> A menor (9,0,4)
                newPcs = [normalizePitch(r + 9), r, t];
                newType = "minor";
            } else { // C menor (0,3,7) -> Eb Mayor (3,7,10)
                newPcs = [normalizePitch(r + 3), f, normalizePitch(t + 7)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        // N (Next Related - Nebenverwandt)
        function opN(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C Mayor (0,4,7) -> F menor (5,8,0)
                newPcs = [normalizePitch(r + 5), normalizePitch(t + 4), r];
                newType = "minor";
            } else { // C menor (0,3,7) -> G Mayor (7,11,2)
                newPcs = [f, normalizePitch(r + 2), normalizePitch(t + 8)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }

        // H (Hexatonic Pole) - equivalent to PLP or LPL
        function opH(triad) {
            let result = opP(triad);
            result = opL(result);
            result = opP(result);
            return result;
        }

        // S (Slide)
        function opS(triad) {
            const [r, t, f] = triad.pitchClasses;
            let newPcs, newType;
            if (triad.type === "major") { // C Mayor (0,4,7) -> C# menor (1,4,8)
                newPcs = [normalizePitch(r + 1), t, normalizePitch(f + 1)];
                newType = "minor";
            } else { // C# menor (1,4,8) -> C Mayor (0,4,7)
                newPcs = [normalizePitch(r - 1), t, normalizePitch(f - 1)];
                newType = "major";
            }
            return findTriadByPitchClasses(newPcs, newType);
        }


        // Corrected Pre-defined Hexatonic Cycles (dynamically generated for accuracy)
        // Each cycle contains 3 major and 3 minor triads.
        const hexatonicCycles = [
            { name: "Ciclo I (C/E/G#)", members: [] }, // Will be populated dynamically
            { name: "Ciclo II (C#/F/A)", members: [] },
            { name: "Ciclo III (D/F#/Bb)", members: [] },
            { name: "Ciclo IV (D#/G/B)", members: [] }
        ];

        // Function to generate and populate a single hexatonic cycle
        function generateAndPopulateHexatonicCycle(startMajorTriad, cycleIndex) {
            const cycle = [];
            let current = startMajorTriad;
            for (let i = 0; i < 6; i++) {
                cycle.push(current);
                if (i % 2 === 0) { // Apply L
                    current = opL(current);
                } else { // Apply P
                    current = opP(current);
                }
            }
            hexatonicCycles[cycleIndex].members = cycle.filter(Boolean); // Ensure no nulls
        }

        // Populate hexatonic cycles after allTriads and operations are defined
        // Ensure these starting triads exist in allTriads.
        generateAndPopulateHexatonicCycle(getTriadByName("C Mayor"), 0); // C-E-G# system
        generateAndPopulateHexatonicCycle(getTriadByName("C# Mayor"), 1); // C#-F-A system
        generateAndPopulateHexatonicCycle(getTriadByName("D Mayor"), 2); // D-F#-Bb system
        generateAndPopulateHexatonicCycle(getTriadByName("D# Mayor"), 3); // D#-G-B system


        // Pre-defined Weitzmann Regions (based on augmented triads C-E-G#, C#-F-A, D-F#-Bb, D#-G-B)
        // Each region contains 3 major and 3 minor triads whose roots form an augmented triad.
        const weitzmannRegions = [
            { name: "Región de C-E-G#", members: [
                getTriadByName("C Mayor"), getTriadByName("C menor"),
                getTriadByName("E Mayor"), getTriadByName("E menor"),
                getTriadByName("G# Mayor"), getTriadByName("G# menor")
            ].filter(Boolean)},
            { name: "Región de C#-F-A", members: [
                getTriadByName("C# Mayor"), getTriadByName("C# menor"),
                getTriadByName("F Mayor"), getTriadByName("F menor"),
                getTriadByName("A Mayor"), getTriadByName("A menor")
            ].filter(Boolean)},
            { name: "Región de D-F#-Bb", members: [
                getTriadByName("D Mayor"), getTriadByName("D menor"),
                getTriadByName("F# Mayor"), getTriadByName("F# menor"),
                getTriadByName("Bb Mayor"), getTriadByName("Bb menor")
            ].filter(Boolean)},
            { name: "Región de D#-G-B", members: [
                getTriadByName("D# Mayor"), getTriadByName("D# menor"),
                getTriadByName("G Mayor"), getTriadByName("G menor"),
                getTriadByName("B Mayor"), getTriadByName("B menor")
            ].filter(Boolean)}
        ];


        // Global state
        let currentTriad;
        let history = [];
        let hexatonicCycleChords = []; // Chords for the current hexatonic cycle visualization

        // DOM Elements
        const startChordSelect = document.getElementById("startChord");
        const resetButton = document.getElementById("resetButton");
        const currentChordName = document.getElementById("currentChordName");
        const currentChordNotes = document.getElementById("currentChordNotes");
        const operationExplanation = document.getElementById("operationExplanation");
        const historyLog = document.getElementById("historyLog");
        const hexatonicCircleSvg = document.querySelector("#hexatonicCircle svg");
        const operationButtons = document.querySelectorAll('.grid button'); // All operation buttons
        const operationsBox = document.getElementById('operationsBox'); // The container for operation buttons

        // DOM elements for new Set Relationships section
        const currentHexatonicCycleSpan = document.getElementById("currentHexatonicCycle");
        const hexatonicCycleMembersDiv = document.getElementById("hexatonicCycleMembers");
        const currentWeitzmannRegionSpan = document.getElementById("currentWeitzmannRegion");
        const weitzmannRegionMembersDiv = document.getElementById("weitzmannRegionMembers");
        const sharedChordsDiv = document.getElementById("sharedChords");


        // Populate initial chord options
        function populateStartChordSelect() {
            // Define a preferred order for enharmonic roots in the dropdown
            // This list ensures each pitch class is represented once, prioritizing common spellings.
            const canonicalRootNames = [
                "C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"
            ];
            
            const uniqueTriadsForDropdown = [];
            
            // Create a temporary map to store triads by their canonical root name
            const canonicalTriadsMap = new Map(); // Map: canonicalRootName -> { major: Triad, minor: Triad }

            allTriads.forEach(triad => {
                let canonicalRoot = triad.root;
                // Determine canonical root name for enharmonic equivalents
                // Prioritize flat spellings for Db, Eb, Ab, Bb
                if (triad.root === "C#") canonicalRoot = "Db";
                else if (triad.root === "D#") canonicalRoot = "Eb";
                else if (triad.root === "Gb") canonicalRoot = "F#"; // F# is generally preferred over Gb
                else if (triad.root === "G#") canonicalRoot = "Ab";
                else if (triad.root === "A#") canonicalRoot = "Bb";

                if (!canonicalTriadsMap.has(canonicalRoot)) {
                    canonicalTriadsMap.set(canonicalRoot, { major: null, minor: null });
                }
                if (triad.type === "major") {
                    canonicalTriadsMap.get(canonicalRoot).major = triad;
                } else {
                    canonicalTriadsMap.get(canonicalRoot).minor = triad;
                }
            });

            // Populate uniqueTriadsForDropdown based on preferredRootOrder
            canonicalRootNames.forEach(rootName => {
                if (canonicalTriadsMap.has(rootName)) {
                    const triadPair = canonicalTriadsMap.get(rootName);
                    if (triadPair.major) uniqueTriadsForDropdown.push(triadPair.major);
                    if (triadPair.minor) uniqueTriadsForDropdown.push(triadPair.minor);
                }
            });

            // Sort uniqueTriadsForDropdown by name for a consistent dropdown order
            const sortedTriads = [...uniqueTriadsForDropdown].sort((a, b) => {
                const rootOrderMap = new Map();
                canonicalRootNames.forEach((root, index) => rootOrderMap.set(root, index));

                // Get the canonical root for sorting purposes
                const getCanonicalRootForSort = (rootName) => {
                    if (rootName === "C#") return "Db";
                    if (rootName === "D#") return "Eb";
                    if (rootName === "Gb") return "F#";
                    if (rootName === "G#") return "Ab";
                    if (rootName === "A#") return "Bb";
                    return rootName;
                };

                const indexA = rootOrderMap.get(getCanonicalRootForSort(a.root));
                const indexB = rootOrderMap.get(getCanonicalRootForSort(b.root));

                if (indexA === indexB) {
                    return a.type.localeCompare(b.type);
                }
                return indexA - indexB;
            });

            sortedTriads.forEach(triad => {
                const option = document.createElement("option");
                option.value = triad.name;
                option.textContent = triad.name;
                startChordSelect.appendChild(option);
            });
            // Set default to C Mayor
            startChordSelect.value = "C Mayor";
        }

        // Initialize or reset the application state
        function initializeApp() {
            const selectedTriadName = startChordSelect.value;
            currentTriad = allTriads.find(t => t.name === selectedTriadName);
            history = [];
            updateUI();
            updateHexatonicCircleVisualization(currentTriad);
            displayOperationExplanation(''); // Clear explanation on reset
            removeActiveOperationHighlight(); // Clear any highlighted operation button
            removeOperationsBoxHighlight(); // Clear operations box highlight
        }

        // Update the UI with current triad information
        function updateUI() {
            currentChordName.textContent = currentTriad.name;
            const notes = currentTriad.getNotes();
            // Display notes explicitly as Root, Third, Fifth
            currentChordNotes.innerHTML = `Raíz: <span class="font-bold">${notes[0]}</span>, Tercera: <span class="font-bold">${notes[1]}</span>, Quinta: <span class="font-bold">${notes[2]}</span>`;
            updateHistoryLog();
            highlightHexatonicNode(currentTriad);
            updateSetRelationshipsDisplay(); // Call new function to update set relationships
        }

        // Add an entry to the history log
        function addHistoryEntry(operationName, oldTriad, newTriad) {
            const entry = {
                operation: operationName,
                from: oldTriad.name,
                to: newTriad.name,
                timestamp: new Date().toLocaleTimeString()
            };
            history.push(entry);
            historyLog.scrollTop = historyLog.scrollHeight; // Scroll to bottom
        }

        // Render the history log
        function updateHistoryLog() {
            historyLog.innerHTML = "";
            if (history.length === 0) {
                historyLog.innerHTML = "<p class='text-gray-500'>No hay transformaciones aún.</p>";
                return;
            }
            history.forEach(entry => {
                const div = document.createElement("div");
                div.className = "history-item";
                div.textContent = `${entry.timestamp}: ${entry.from} --(${entry.operation})--> ${entry.to}`;
                historyLog.appendChild(div);
            });
        }

        // Helper to find a triad by its pitch classes (for operations that might generate new note names)
        function findTriadByPitchClasses(pcs, type) {
            const sortedPcs = [...pcs].sort();
            for (const triad of allTriads) {
                const sortedTriadPcs = [...triad.pitchClasses].sort();
                if (triad.type === type && sortedPcs.every((pc, i) => pc === sortedTriadPcs[i])) {
                    return triad;
                }
            }
            return null;
        }

        // --- Set Relationship Functions ---
        function getHexatonicCycleForTriad(triad) {
            for (const cycle of hexatonicCycles) {
                // CRITICAL FIX: Use hasSamePitchClasses for membership check
                if (cycle.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return cycle;
                }
            }
            return null;
        }

        function getWeitzmannRegionForTriad(triad) {
            for (const region of weitzmannRegions) {
                // CRITICAL FIX: Use hasSamePitchClasses for membership check
                if (region.members.some(member => member.hasSamePitchClasses(triad) && member.type === triad.type)) {
                    return region;
                }
            }
            return null;
        }

        function updateSetRelationshipsDisplay() {
            const hexCycle = getHexatonicCycleForTriad(currentTriad);
            const weitzRegion = getWeitzmannRegionForTriad(currentTriad);

            if (hexCycle) {
                currentHexatonicCycleSpan.textContent = hexCycle.name;
                hexatonicCycleMembersDiv.innerHTML = hexCycle.members.map(t => `<span class="bg-blue-100 text-blue-800 px-2 py-1 rounded-md">${t.name}</span>`).join('');
            } else {
                currentHexatonicCycleSpan.textContent = "No encontrado";
                hexatonicCycleMembersDiv.innerHTML = "";
            }

            if (weitzRegion) {
                currentWeitzmannRegionSpan.textContent = weitzRegion.name;
                weitzmannRegionMembersDiv.innerHTML = weitzRegion.members.map(t => `<span class="bg-green-100 text-green-800 px-2 py-1 rounded-md">${t.name}</span>`).join('');
            } else {
                currentWeitzmannRegionSpan.textContent = "No encontrado";
                weitzmannRegionMembersDiv.innerHTML = "";
            }

            // Find shared chords
            if (hexCycle && weitzRegion) {
                const shared = hexCycle.members.filter(hexMember =>
                    weitzRegion.members.some(weitzMember => weitzMember.hasSamePitchClasses(hexMember) && weitzMember.type === hexMember.type)
                );
                sharedChordsDiv.innerHTML = shared.map(t => `<span class="bg-purple-100 text-purple-800 px-2 py-1 rounded-md">${t.name}</span>`).join('');
            } else {
                sharedChordsDiv.innerHTML = "<p class='text-gray-500'>No hay conjuntos para comparar.</p>";
            }
        }


        // --- Hexatonic Cycle Visualization (corrected logic) ---
        function updateHexatonicCircleVisualization(activeTriad) {
            hexatonicCircleSvg.innerHTML = `<defs>
                                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                                    <polygon points="0 0, 10 3.5, 0 7" />
                                                </marker>
                                            </defs>`; // Clear previous nodes/arrows

            const foundCycle = getHexatonicCycleForTriad(activeTriad);

            if (!foundCycle) {
                hexatonicCircleSvg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#64748b" class="text-xs">El acorde actual no está en el ciclo hexatónico visualizado.</text>`;
                hexatonicCycleChords = []; // Clear the cycle chords
                return;
            }

            // Directly use the members of the found cycle for visualization
            hexatonicCycleChords = foundCycle.members;

            const centerX = 150;
            const centerY = 150;
            const radius = 120;
            const nodeWidth = 60;
            const nodeHeight = 30;

            hexatonicCycleChords.forEach((triad, index) => {
                const angle = (index * (360 / hexatonicCycleChords.length) - 90) * Math.PI / 180; // -90 to start at top
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const node = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                node.setAttribute("x", x - nodeWidth / 2);
                node.setAttribute("y", y - nodeHeight / 2);
                node.setAttribute("width", nodeWidth);
                node.setAttribute("height", nodeHeight);
                node.classList.add("chord-node");
                // Use hasSamePitchClasses for highlighting in visualization
                if (triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type) {
                    node.classList.add("active");
                }
                node.innerHTML = `<div class="w-full h-full flex items-center justify-center">${triad.name}</div>`;
                hexatonicCircleSvg.appendChild(node);

                node.addEventListener('click', () => {
                    // When clicking a node, use its exact root and type to set currentTriad
                    // Find the triad by its name to ensure we get the canonical object
                    currentTriad = getTriadByName(triad.name);
                    history = [];
                    updateUI();
                    updateHexatonicCircleVisualization(currentTriad);
                    displayOperationExplanation('');
                    removeActiveOperationHighlight();
                    removeOperationsBoxHighlight();
                });

                const nextIndex = (index + 1) % hexatonicCycleChords.length;
                const nextTriad = hexatonicCycleChords[nextIndex];

                const nextAngle = (nextIndex * (360 / hexatonicCycleChords.length) - 90) * Math.PI / 180;
                const nextX = centerX + radius * Math.cos(nextAngle);
                const nextY = centerY + radius * Math.sin(nextAngle);

                let isArrowActive = false;
                // Determine if the operation between current and next is L or P for active arrow
                // This logic is based on the predefined cycle order (L then P)
                if (triad.hasSamePitchClasses(activeTriad) && triad.type === activeTriad.type) {
                    const expectedNextByL = opL(triad);
                    const expectedNextByP = opP(triad);

                    if (expectedNextByL && expectedNextByL.hasSamePitchClasses(nextTriad) && expectedNextByL.type === nextTriad.type) {
                        isArrowActive = true;
                    } else if (expectedNextByP && expectedNextByP.hasSamePitchClasses(nextTriad) && expectedNextByP.type === nextTriad.type) {
                        isArrowActive = true;
                    }
                }

                drawArrow(hexatonicCircleSvg, x, y, nextX, nextY, nodeWidth / 2, isArrowActive);
            });
        }

        function drawArrow(svg, x1, y1, x2, y2, offset, isActive = false) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const startX = x1 + offset * Math.cos(angle);
            const startY = y1 + offset * Math.sin(angle);
            const endX = x2 - offset * Math.cos(angle);
            const endY = y2 - offset * Math.sin(angle);

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", `M ${startX} ${startY} L ${endX} ${endY}`);
            path.setAttribute("class", `arrow ${isActive ? 'arrow-active' : ''}`);
            svg.appendChild(path);
        }

        function highlightHexatonicNode(triadToHighlight) {
            document.querySelectorAll('.chord-node').forEach(node => {
                node.classList.remove('active');
            });
            // Use hasSamePitchClasses for finding the node to highlight
            const index = hexatonicCycleChords.findIndex(t => t.hasSamePitchClasses(triadToHighlight) && t.type === triadToHighlight.type);
            if (index !== -1) {
                const nodeElement = hexatonicCircleSvg.children[index + 1]; // +1 because of <defs>
                if (nodeElement) {
                    nodeElement.classList.add('active');
                }
            }
        }

        // Function to highlight the active operation button
        function highlightActiveOperation(opCode) {
            removeActiveOperationHighlight(); // First, remove any existing highlight
            const button = document.querySelector(`[data-op="${opCode}"]`);
            if (button) {
                button.classList.add('active-op-btn');
            }
            highlightOperationsBox(); // Highlight the operations box
        }

        // Function to remove all active operation button highlights
        function removeActiveOperationHighlight() {
            operationButtons.forEach(button => {
                button.classList.remove('active-op-btn');
            });
        }

        // Function to highlight the operations box
        function highlightOperationsBox() {
            operationsBox.classList.add('operations-box-active');
        }

        // Function to remove operations box highlight
        function removeOperationsBoxHighlight() {
            operationsBox.classList.remove('operations-box-active');
        }


        // Event Listeners
        resetButton.addEventListener("click", initializeApp);

        document.getElementById("opL").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opL(currentTriad);
            addHistoryEntry("L", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("L");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opP").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opP(currentTriad);
            addHistoryEntry("P", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("P");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opR").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opR(currentTriad);
            addHistoryEntry("R", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("R");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opN").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opN(currentTriad);
            addHistoryEntry("N", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("N");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opH").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opH(currentTriad);
            addHistoryEntry("H", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("H");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        document.getElementById("opS").addEventListener("click", (event) => {
            const oldTriad = currentTriad;
            currentTriad = opS(currentTriad);
            addHistoryEntry("S", oldTriad, currentTriad);
            updateUI();
            displayOperationExplanation("S");
            updateHexatonicCircleVisualization(currentTriad);
            highlightActiveOperation(event.target.dataset.op);
        });

        // Initial setup on page load
        window.onload = () => {
            populateStartChordSelect();
            initializeApp();
        };
    </script>
</body>
</html>

